<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<title>CMake Cross Platform Make</title>
<style type="text/css">
    p, li {
        font-family: verdana, helvetica, sans;
        font-size: 12px;
      }
    </style>
</head>
<body>
<h2>Documentation for Commands of CMake 2.4-patch 7 RC-5</h2>
<ul>
    <li><b><code><a name="ADD_CUSTOM_COMMAND">ADD_CUSTOM_COMMAND</a></code></b>: Add a custom build
    rule to the generated build system.<br>
    <p>There are two main signatures for ADD_CUSTOM_COMMAND The
    first signature is for adding a custom command to produce an output.<br>
    </p>
    <pre>  ADD_CUSTOM_COMMAND(OUTPUT output1 [output2 ...]<br>                     COMMAND command1 [ARGS] [args1...]<br>                     [COMMAND command2 [ARGS] [args2...] ...]<br>                     [MAIN_DEPENDENCY depend]<br>                     [DEPENDS [depends...]]<br>                     [WORKING_DIRECTORY dir]<br>                     [COMMENT comment] [VERBATIM] [APPEND])<br></pre>
    <p>This defines a new command that can be executed during the
    build process. The outputs named should be listed as source files in
    the target for which they are to be generated. Note that
    MAIN_DEPENDENCY is completely optional and is used as a suggestion
    to visual studio about where to hang the custom command. In makefile
    terms this creates a new target in the following form:<br>
    </p>
    <pre>  OUTPUT: MAIN_DEPENDENCY DEPENDS<br>          COMMAND<br></pre>
    <p>If more than one command is specified they will be executed
    in order. The optional ARGS argument is for backward compatibility
    and will be ignored.<br>
    </p>
    <p>The second signature adds a custom command to a target such
    as a library or executable. This is useful for performing an
    operation before or after building the target:<br>
    </p>
    <pre>  ADD_CUSTOM_COMMAND(TARGET target<br>                     PRE_BUILD | PRE_LINK | POST_BUILD<br>                     COMMAND command1 [ARGS] [args1...]<br>                     [COMMAND command2 [ARGS] [args2...] ...]<br>                     [WORKING_DIRECTORY dir]<br>                     [COMMENT comment] [VERBATIM])<br></pre>
    <p>This defines a new command that will be associated with
    building the specified target. When the command will happen is
    determined by which of the following is specified:<br>
    </p>
    <pre>  PRE_BUILD - run before all other dependencies<br>  PRE_LINK - run after other dependencies<br>  POST_BUILD - run after the target has been built<br></pre>
    <p>Note that the PRE_BUILD option is only supported on Visual
    Studio 7 or later. For all other generators PRE_BUILD will be
    treated as PRE_LINK.<br>
    </p>
    <p>If WORKING_DIRECTORY is specified the command will be
    executed in the directory given. If COMMENT is set, the value will
    be displayed as a message before the commands are executed at build
    time. If APPEND is specified the COMMAND and DEPENDS option values
    are appended to the custom command for the first output specified.
    There must have already been a previous call to this command with
    the same output. The COMMENT, WORKING_DIRECTORY, and MAIN_DEPENDENCY
    options are currently ignored when APPEND is given, but may be used
    in the future.<br>
    </p>
    <p>If VERBATIM is given then all the arguments to the commands
    will be passed exactly as specified no matter the build tool used.
    Note that one level of escapes is still used by the CMake language
    processor before ADD_CUSTOM_TARGET even sees the arguments. Use of
    VERBATIM is recommended as it enables correct behavior. When
    VERBATIM is not given the behavior is platform specific. In the
    future VERBATIM may be enabled by default. The only reason it is an
    option is to preserve compatibility with older CMake code.<br>
    </p>
    <p>If the output of the custom command is not actually created
    as a file on disk it should be marked as SYMBOLIC with
    SET_SOURCE_FILES_PROPERTIES.</p>
    </li>
    
    <li><b><code><a name="ADD_CUSTOM_TARGET">ADD_CUSTOM_TARGET</a></code></b>: Add a target with no
    output so it will always be built.<br>
    <pre>  ADD_CUSTOM_TARGET(Name [ALL] [command1 [args1...]]<br>                    [COMMAND command2 [args2...] ...]<br>                    [DEPENDS depend depend depend ... ]<br>                    [WORKING_DIRECTORY dir]<br>                    [COMMENT comment] [VERBATIM])<br></pre>
    <p>Adds a target with the given name that executes the given
    commands. The target has no output file and is ALWAYS CONSIDERED OUT
    OF DATE even if the commands try to create a file with the name of
    the target. Use ADD_CUSTOM_COMMAND to generate a file with
    dependencies. By default nothing depends on the custom target. Use
    ADD_DEPENDENCIES to add dependencies to or from other targets. If
    the ALL option is specified it indicates that this target should be
    added to the default build target so that it will be run every time
    (the command cannot be called ALL). The command and arguments are
    optional and if not specified an empty target will be created. If
    WORKING_DIRECTORY is set, then the command will be run in that
    directory. If COMMENT is set, the value will be displayed as a
    message before the commands are executed at build time. Dependencies
    listed with the DEPENDS argument may reference files and outputs of
    custom commands created with ADD_CUSTOM_COMMAND.<br>
    </p>
    <p>If VERBATIM is given then all the arguments to the commands
    will be passed exactly as specified no matter the build tool used.
    Note that one level of escapes is still used by the CMake language
    processor before ADD_CUSTOM_TARGET even sees the arguments. Use of
    VERBATIM is recommended as it enables correct behavior. When
    VERBATIM is not given the behavior is platform specific. In the
    future VERBATIM may be enabled by default. The only reason it is an
    option is to preserve compatibility with older CMake code.</p>
    </li>
    
    <li><b><code><a name="ADD_DEFINITIONS">ADD_DEFINITIONS</a></code></b>: Adds -D define flags
    to the command line of C and C++ compilers.<br>
    <pre>  ADD_DEFINITIONS(-DFOO -DBAR ...)<br></pre>
    <p>Adds flags to command line of C and C++ compilers. This
    command can be used to add any flag to a compile line, but the -D
    flag is accepted most C/C++ compilers. Other flags may not be as
    portable.</p>
    </li>
    
    <li><b><code><a name="ADD_DEPENDENCIES">ADD_DEPENDENCIES</a></code></b>: Add a dependency
    between top-level targets.<br>
    <pre>  ADD_DEPENDENCIES(target-name depend-target1<br>                   depend-target2 ...)<br></pre>
    <p>Make a top-level target depend on other top-level targets. A
    top-level target is one created by ADD_EXECUTABLE, ADD_LIBRARY, or
    ADD_CUSTOM_TARGET. Adding dependencies with this command can be used
    to make sure one target is built before another target. See the
    DEPENDS option of ADD_CUSTOM_TARGET and ADD_CUSTOM_COMMAND for
    adding file-level dependencies in custom rules. See the
    OBJECT_DEPENDS option in SET_SOURCE_FILES_PROPERTIES to add
    file-level dependencies to object files.</p>
    </li>
    
    <li><b><code><a name="ADD_EXECUTABLE">ADD_EXECUTABLE</a></code></b>: Add an executable to
    the project using the specified source files.<br>
    <pre>  ADD_EXECUTABLE(exename [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL]<br>                 source1 source2 ... sourceN)<br></pre>
    <p>This command adds an executable target to the current
    directory. The executable will be built from the list of source
    files specified.<br>
    </p>
    <p>After specifying the executable name, WIN32 and/or
    MACOSX_BUNDLE can be specified. WIN32 indicates that the executable
    (when compiled on windows) is a windows app (using WinMain) not a
    console app (using main). The variable CMAKE_MFC_FLAG be used if the
    windows app uses MFC. This variable can be set to the following
    values:<br>
    </p>
    <pre> 0: Use Standard Windows Libraries<br> 1: Use MFC in a Static Library <br> 2: Use MFC in a Shared DLL <br></pre>
    <p>MACOSX_BUNDLE indicates that when build on Mac OSX,
    executable should be in the bundle form. The MACOSX_BUNDLE also
    allows several variables to be specified:<br>
    </p>
    <pre>  MACOSX_BUNDLE_INFO_STRING<br>  MACOSX_BUNDLE_ICON_FILE<br>  MACOSX_BUNDLE_GUI_IDENTIFIER<br>  MACOSX_BUNDLE_LONG_VERSION_STRING<br>  MACOSX_BUNDLE_BUNDLE_NAME<br>  MACOSX_BUNDLE_SHORT_VERSION_STRING<br>  MACOSX_BUNDLE_BUNDLE_VERSION<br>  MACOSX_BUNDLE_COPYRIGHT<br></pre>
    <p>If EXCLUDE_FROM_ALL is given the target will not be built by
    default. It will be built only if the user explicitly builds the
    target or another target that requires the target depends on it.</p>
    </li>
    
    <li><b><code><a name="ADD_LIBRARY">ADD_LIBRARY</a></code></b>: Add a library to the
    project using the specified source files.<br>
    <pre>  ADD_LIBRARY(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL]<br>              source1 source2 ... sourceN)<br></pre>
    <p>Adds a library target. SHARED, STATIC or MODULE keywords are
    used to set the library type. If the keyword MODULE appears, the
    library type is set to MH_BUNDLE on systems which use dyld. On
    systems without dyld, MODULE is treated like SHARED. If no keywords
    appear as the second argument, the type defaults to the current
    value of BUILD_SHARED_LIBS. If this variable is not set, the type
    defaults to STATIC.<br>
    </p>
    <p>If EXCLUDE_FROM_ALL is given the target will not be built by
    default. It will be built only if the user explicitly builds the
    target or another target that requires the target depends on it.</p>
    </li>
    
    <li><b><code><a name="ADD_SUBDIRECTORY">ADD_SUBDIRECTORY</a></code></b>: Add a subdirectory to
    the build.<br>
    <pre>  ADD_SUBDIRECTORY(source_dir [binary_dir] <br>                   [EXCLUDE_FROM_ALL])<br></pre>
    <p>Add a subdirectory to the build. The source_dir specifies the
    directory in which the source CmakeLists.txt and code files are
    located. If it is a relative path it will be evaluated with respect
    to the current directory (the typical usage), but it may also be an
    absolute path. The binary_dir specifies the directory in which to
    place the output files. If it is a relative path it will be
    evaluated with respect to the current output directory, but it may
    also be an absolute path. If binary_dir is not specified, the value
    of source_dir, before expanding any relative path, will be used (the
    typical usage). The CMakeLists.txt file in the specified source
    directory will be processed immediately by CMake before processing
    in the current input file continues beyond this command.<br>
    </p>
    <p>If the EXCLUDE_FROM_ALL argument is provided then this
    subdirectory will not be included in build by default. Users will
    have to explicitly start a build in the generated output directory.
    This is useful for having cmake create a build system for a set of
    examples in a project. One would want cmake to generate a single
    build system for all the examples, but one may not want the targets
    to show up in the main build system.</p>
    </li>
    
    <li><b><code><a name="ADD_TEST">ADD_TEST</a></code></b>: Add a test to the project
    with the specified arguments.<br>
    <pre>  ADD_TEST(testname Exename arg1 arg2 ...)<br></pre>
    <p>If the ENABLE_TESTING command has been run, this command adds
    a test target to the current directory. If ENABLE_TESTING has not
    been run, this command does nothing. The tests are run by the
    testing subsystem by executing Exename with the specified arguments.
    Exename can be either an executable built by this project or an
    arbitrary executable on the system (like tclsh). The test will be
    run with the current working directory set to the CMakeList.txt
    files corresponding directory in the binary tree.</p>
    </li>
    
    <li><b><code><a name="AUX_SOURCE_DIRECTORY">AUX_SOURCE_DIRECTORY</a></code></b>: Find all source
    files in a directory.<br>
    <pre>  AUX_SOURCE_DIRECTORY(dir VARIABLE)<br></pre>
    <p>Collects the names of all the source files in the specified
    directory and stores the list in the variable provided. This command
    is intended to be used by projects that use explicit template
    instantiation. Template instantiation files can be stored in a
    "Templates" subdirectory and collected automatically using this
    command to avoid manually listing all instantiations.<br>
    </p>
    <p>It is tempting to use this command to avoid writing the list
    of source files for a library or executable target. While this seems
    to work, there is no way for CMake to generate a build system that
    knows when a new source file has been added. Normally the generated
    build system knows when it needs to rerun CMake because the
    CMakeLists.txt file is modified to add a new source. When the source
    is just added to the directory without modifying this file, one
    would have to manually rerun CMake to generate a build system
    incorporating the new file.</p>
    </li>
    
    <li><b><code><a name="BUILD_COMMAND">BUILD_COMMAND</a></code></b>: Get the command line
    that will build this project.<br>
    <pre>  BUILD_COMMAND(variable MAKECOMMAND)<br></pre>
    <p>Sets the given variable to a string containing the command
    that will build this project from the root of the build tree using
    the build tool given by MAKECOMMAND. MAKECOMMAND should be msdev,
    nmake, make or one of the end user build tools. This is useful for
    configuring testing systems.</p>
    </li>
    
    <li><b><code><a name="BUILD_NAME">BUILD_NAME</a></code></b>: Deprecated. Use
    ${CMAKE_SYSTEM} and ${CMAKE_CXX_COMPILER} instead.<br>
    <pre>  BUILD_NAME(variable)<br></pre>
    <p>Sets the specified variable to a string representing the
    platform and compiler settings. These values are now available
    through the CMAKE_SYSTEM and CMAKE_CXX_COMPILER variables.</p>
    </li>
    
    <li><b><code><a name="CMAKE_MINIMUM_REQUIRED">CMAKE_MINIMUM_REQUIRED</a></code></b>: Set the minimum
    required version of cmake for a project.<br>
    <pre>  CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])<br></pre>
    <p>Let cmake know that the project requires a certain version of
    a cmake, or newer. CMake will also try to be backwards compatible to
    the version of cmake specified, if a newer version of cmake is
    running. If FATAL_ERROR is given then failure to meet the
    requirements will be considered an error instead of a warning.</p>
    </li>
    
    <li><b><code><a name="CONFIGURE_FILE">CONFIGURE_FILE</a></code></b>: Copy a file to another
    location and modify its contents.<br>
    <pre>  CONFIGURE_FILE(InputFile OutputFile<br>                 [COPYONLY] [ESCAPE_QUOTES] [@ONLY])<br></pre>
    <p>The Input and Ouput files have to have full paths. This
    command replaces any variables in the input file referenced as
    ${VAR} or @VAR@ with their values as determined by CMake. If a
    variable is not defined, it will be replaced with nothing. If
    COPYONLY is specified, then no variable expansion will take place.
    If ESCAPE_QUOTES is specified then any substituted quotes will be
    C-style escaped. The file will be configured with the current values
    of CMake variables. If @ONLY is specified, only variables of the
    form @VAR@ will be replaces and ${VAR} will be ignored. This is
    useful for configuring scripts that use ${VAR}. Any occurrences of
    #cmakedefine VAR will be replaced with either #define VAR or /*
    #undef VAR */ depending on the setting of VAR in CMake</p>
    </li>
    
    <li><b><code><a name="CREATE_TEST_SOURCELIST">CREATE_TEST_SOURCELIST</a></code></b>: Create a test
    driver and source list for building test programs.<br>
    <pre>  CREATE_TEST_SOURCELIST(SourceListName DriverName<br>                         test1 test2 test3<br>                         EXTRA_INCLUDE include.h<br>                         FUNCTION function)<br></pre>
    <p>A test driver is a program that links together many small
    tests into a single executable. This is useful when building static
    executables with large libraries to shrink the total required size.
    The list of source files needed to build the test driver will be in
    SourceListName. DriverName is the name of the test driver program.
    The rest of the arguments consist of a list of test source files,
    can be semicolon separated. Each test source file should have a
    function in it that is the same name as the file with no extension
    (foo.cxx should have int foo();) DriverName will be able to call
    each of the tests by name on the command line. If EXTRA_INCLUDE is
    specified, then the next argument is included into the generated
    file. If FUNCTION is specified, then the next argument is taken as a
    function name that is passed a pointer to ac and av. This can be
    used to add extra command line processing to each test. The cmake
    variable CMAKE_TESTDRIVER_BEFORE_TESTMAIN can be set to have code
    that will be placed directly before calling the test main function.
    CMAKE_TESTDRIVER_AFTER_TESTMAIN can be set to have code that will be
    placed directly after the call to the test main function.</p>
    </li>
    
    <li><b><code><a name="ELSE">ELSE</a></code></b>: Starts the ELSE portion of an IF
    block.<br>
    <pre>  ELSE(expression)<br></pre>
    <p>See the IF command.</p>
    </li>
    
    <li><b><code><a name="ELSEIF">ELSEIF</a></code></b>: Starts the ELSEIF portion of an
    IF block.<br>
    <pre>  ELSEIF(expression)<br></pre>
    <p>See the IF command.</p>
    </li>
    
    <li><b><code><a name="ENABLE_LANGUAGE">ENABLE_LANGUAGE</a></code></b>: Set a name for the
    entire project.<br>
    <pre>  ENABLE_LANGUAGE(languageName)<br></pre>
    <p>This command enables support for the named language in CMake.
    </p>
    </li>
    
    <li><b><code><a name="ENABLE_TESTING">ENABLE_TESTING</a></code></b>: Enable testing for
    current directory and below.<br>
    <pre>  ENABLE_TESTING()<br></pre>
    <p>Enables testing for this directory and below. See also the
    ADD_TEST command. Note that ctest expects to find a test file in the
    build directory root. Therefore, this command should be in the
    source directory root.</p>
    </li>
    
    <li><b><code><a name="ENDFOREACH">ENDFOREACH</a></code></b>: Ends a list of commands in
    a FOREACH block.<br>
    <pre>  ENDFOREACH(expression)<br></pre>
    <p>See the FOREACH command.</p>
    </li>
    
    <li><b><code><a name="ENDIF">ENDIF</a></code></b>: Ends a list of commands in an IF
    block.<br>
    <pre>  ENDIF(expression)<br></pre>
    <p>See the IF command.</p>
    </li>
    
    <li><b><code><a name="ENDMACRO">ENDMACRO</a></code></b>: Ends a list of commands in a
    MACRO block.<br>
    <pre>  ENDMACRO(expression)<br></pre>
    <p>See the MACRO command.</p>
    </li>
    
    <li><b><code><a name="ENDWHILE">ENDWHILE</a></code></b>: Ends a list of commands in a
    WHILE block.<br>
    <pre>  ENDWHILE(expression)<br></pre>
    <p>See the WHILE command.</p>
    </li>
    
    <li><b><code><a name="EXEC_PROGRAM">EXEC_PROGRAM</a></code></b>: Run and executable
    program during the processing of the CMakeList.txt file.<br>
    <pre>  EXEC_PROGRAM(Executable [directory in which to run]<br>               [ARGS &lt;arguments to executable&gt;]<br>               [OUTPUT_VARIABLE &lt;var&gt;]<br>               [RETURN_VALUE &lt;var&gt;])<br></pre>
    <p>The executable is run in the optionally specified directory.
    The executable can include arguments if it is double quoted, but it
    is better to use the optional ARGS argument to specify arguments to
    the program. This is because cmake will then be able to escape
    spaces in the executable path. An optional argument OUTPUT_VARIABLE
    specifies a variable in which to store the output. To capture the
    return value of the execution, provide a RETURN_VALUE. If
    OUTPUT_VARIABLE is specified, then no output will go to the
    stdout/stderr of the console running cmake.<br>
    </p>
    <p>The EXECUTE_PROCESS command is a newer more powerful version
    of EXEC_PROGRAM, but the old command has been kept for
    compatibility.</p>
    </li>
    
    <li><b><code><a name="EXECUTE_PROCESS">EXECUTE_PROCESS</a></code></b>: Execute one or more
    child processes.<br>
    <pre>  EXECUTE_PROCESS(COMMAND &lt;cmd1&gt; [args1...]]<br>                  [COMMAND &lt;cmd2&gt; [args2...] [...]]<br>                  [WORKING_DIRECTORY &lt;directory&gt;]<br>                  [TIMEOUT &lt;seconds&gt;]<br>                  [RESULT_VARIABLE &lt;variable&gt;]<br>                  [OUTPUT_VARIABLE &lt;variable&gt;]<br>                  [ERROR_VARIABLE &lt;variable&gt;]<br>                  [INPUT_FILE &lt;file&gt;]<br>                  [OUTPUT_FILE &lt;file&gt;]<br>                  [ERROR_FILE &lt;file&gt;]<br>                  [OUTPUT_QUIET]<br>                  [ERROR_QUIET]<br>                  [OUTPUT_STRIP_TRAILING_WHITESPACE]<br>                  [ERROR_STRIP_TRAILING_WHITESPACE])<br></pre>
    <p>Runs the given sequence of one or more commands with the
    standard output of each process piped to the standard input of the
    next. A single standard error pipe is used for all processes. If
    WORKING_DIRECTORY is given the named directory will be set as the
    current working directory of the child processes. If TIMEOUT is
    given the child processes will be terminated if they do not finish
    in the specified number of seconds (fractions are allowed). If
    RESULT_VARIABLE is given the variable will be set to contain the
    result of running the processes. This will be an integer return code
    from the last child or a string describing an error condition. If
    OUTPUT_VARIABLE or ERROR_VARIABLE are given the variable named will
    be set with the contents of the standard output and standard error
    pipes respectively. If the same variable is named for both pipes
    their output will be merged in the order produced. If INPUT_FILE,
    OUTPUT_FILE, or ERROR_FILE is given the file named will be attached
    to the standard input of the first process, standard output of the
    last process, or standard error of all processes respectively. If
    OUTPUT_QUIET or ERROR_QUIET is given then the standard output or
    standard error results will be quietly ignored. If more than one
    OUTPUT_* or ERROR_* option is given for the same pipe the precedence
    is not specified. If no OUTPUT_* or ERROR_* options are given the
    output will be shared with the corresponding pipes of the CMake
    process itself.<br>
    </p>
    <p>The EXECUTE_PROCESS command is a newer more powerful version
    of EXEC_PROGRAM, but the old command has been kept for
    compatibility.</p>
    </li>
    
    <li><b><code><a name="EXPORT_LIBRARY_DEPENDENCIES">EXPORT_LIBRARY_DEPENDENCIES</a></code></b>: Write out
    the dependency information for all targets of a project.<br>
    <pre>  EXPORT_LIBRARY_DEPENDENCIES(FILE [APPEND])<br></pre>
    <p>Create a file that can be included into a CMake listfile with
    the INCLUDE command. The file will contain a number of SET commands
    that will set all the variables needed for library dependency
    information. This should be the last command in the top level
    CMakeLists.txt file of the project. If the APPEND option is
    specified, the SET commands will be appended to the given file
    instead of replacing it.</p>
    </li>
    
    <li><b><code><a name="FILE">FILE</a></code></b>: File manipulation command.<br>
    <pre>  FILE(WRITE filename "message to write"... )<br>  FILE(APPEND filename "message to write"... )<br>  FILE(READ filename variable)<br>  FILE(GLOB variable [RELATIVE path] [globbing expressions]...)<br>  FILE(GLOB_RECURSE variable [RELATIVE path] <br>       [globbing expressions]...)<br>  FILE(REMOVE [directory]...)<br>  FILE(REMOVE_RECURSE [directory]...)<br>  FILE(MAKE_DIRECTORY [directory]...)<br>  FILE(RELATIVE_PATH variable directory file)<br>  FILE(TO_CMAKE_PATH path result)<br>  FILE(TO_NATIVE_PATH path result)<br></pre>
    <p>WRITE will write a message into a file called 'filename'. It
    overwrites the file if it already exists, and creates the file if it
    does not exist.<br>
    </p>
    <p>APPEND will write a message into a file same as WRITE, except
    it will append it to the end of the file<br>
    </p>
    <p>NOTE: When using FILE WRITE and FILE APPEND, the produced
    file cannot be used as an input to CMake (CONFIGURE_FILE, source
    file ...) because it will lead to an infinite loop. Use
    CONFIGURE_FILE if you want to generate input files to CMake.<br>
    </p>
    <p>READ will read the content of a file and store it into the
    variable.<br>
    </p>
    <p>GLOB will generate a list of all files that match the
    globbing expressions and store it into the variable. Globbing
    expressions are similar to regular expressions, but much simpler. If
    RELATIVE flag is specified for an expression, the results will be
    returned as a relative path to the given path.<br>
    </p>
    <p>Examples of globbing expressions include:<br>
    </p>
    <pre>   *.cxx      - match all files with extension cxx<br>   *.vt?      - match all files with extension vta,...,vtz<br>   f[3-5].txt - match files f3.txt, f4.txt, f5.txt<br></pre>
    <p>GLOB_RECURSE will generate similar list as the regular GLOB,
    except it will traverse all the subdirectories of the matched
    directory and match the files.<br>
    </p>
    <p>Examples of recursive globbing include:<br>
    </p>
    <pre>   /dir/*.py  - match all python files in /dir and subdirectories<br></pre>
    <p>MAKE_DIRECTORY will create a directory at the specified
    location<br>
    </p>
    <p>RELATIVE_PATH will determine relative path from directory to
    the given file.<br>
    </p>
    <p>TO_CMAKE_PATH will convert path into a cmake style path with
    unix /. The input can be a single path or a system path like
    "$ENV{PATH}". Note the double quotes around the ENV call
    TO_CMAKE_PATH only takes one argument.<br>
    </p>
    <p>TO_NATIVE_PATH works just like TO_CMAKE_PATH, but will
    convert from a cmake style path into the native path style \ for
    windows and / for UNIX.</p>
    </li>
    
    <li><b><code><a name="FIND_FILE">FIND_FILE</a></code></b>: Find the full path to a
    file.<br>
    <pre>   FIND_FILE(&lt;VAR&gt; name1 path1 path2 ...)<br></pre>
    <p>This is the short-hand signature for the command that is
    sufficient in many cases. It is the same as FIND_FILE(&lt;VAR&gt;
    name1 PATHS path2 path2 ...)<br>
    </p>
    <pre>   FIND_FILE(<br>             &lt;VAR&gt; <br>             name | NAMES name1 [name2 ...]<br>             PATHS path1 [path2 ... ENV var]<br>             [PATH_SUFFIXES suffix1 [suffix2 ...]]<br>             [DOC "cache documentation string"]<br>             [NO_DEFAULT_PATH]<br>             [NO_CMAKE_ENVIRONMENT_PATH]<br>             [NO_CMAKE_PATH]<br>             [NO_SYSTEM_ENVIRONMENT_PATH]<br>             [NO_CMAKE_SYSTEM_PATH]<br>            )<br></pre>
    <p>This command is used to find a full path to named file. A
    cache entry named by &lt;VAR&gt; is created to store the result of
    this command. If the full path to a file is found the result is
    stored in the variable and the search will not be repeated unless
    the variable is cleared. If nothing is found, the result will be
    &lt;VAR&gt;-NOTFOUND, and the search will be attempted again the
    next time FIND_FILE is invoked with the same variable. The name of
    the full path to a file that is searched for is specified by the
    names listed after the NAMES argument. Additional search locations
    can be specified after the PATHS argument. If ENV var is found in
    the PATHS section the environment variable var will be read and
    converted from a system environment variable to a cmake style list
    of paths. For example ENV PATH would be a way to list the system
    path variable. The argument after DOC will be used for the
    documentation string in the cache. PATH_SUFFIXES can be used to give
    sub directories that will be appended to the search paths.<br>
    </p>
    <p>If NO_DEFAULT_PATH is specified, then no additional paths are
    added to the search. If NO_DEFAULT_PATH is not specified, the search
    process is as follows:<br>
    </p>
    <p>1. Search cmake specific environment variables. This can be
    skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.<br>
    </p>
    <pre>   CMAKE_FRAMEWORK_PATH<br>   CMAKE_APPBUNDLE_PATH<br>   CMAKE_INCLUDE_PATH<br></pre>
    <p>2. Search cmake variables with the same names as the cmake
    specific environment variables. These are intended to be used on the
    command line with a -DVAR=value. This can be skipped if
    NO_CMAKE_PATH is passed.<br>
    </p>
    <pre>   CMAKE_FRAMEWORK_PATH<br>   CMAKE_APPBUNDLE_PATH<br>   CMAKE_INCLUDE_PATH<br></pre>
    <p>3. Search the standard system environment variables. This can
    be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.<br>
    </p>
    <pre>   PATH<br>   INCLUDE<br></pre>
    <p>4. Search cmake variables defined in the Platform files for
    the current system. This can be skipped if NO_CMAKE_SYSTEM_PATH is
    passed.<br>
    </p>
    <pre>   CMAKE_SYSTEM_FRAMEWORK_PATH<br>   CMAKE_SYSTEM_APPBUNDLE_PATH<br>   CMAKE_SYSTEM_INCLUDE_PATH<br></pre>
    <p>5. Search the paths specified after PATHS or in the
    short-hand version of the command.<br>
    </p>
    <p>On Darwin or systems supporting OSX Frameworks, the cmake
    variable CMAKE_FIND_FRAMEWORK can be set to empty or one of the
    following:<br>
    </p>
    <pre>   "FIRST"  - Try to find frameworks before standard<br>              libraries or headers. This is the default on Darwin.<br>   "LAST"   - Try to find frameworks after standard<br>              libraries or headers.<br>   "ONLY"   - Only try to find frameworks.<br>   "NEVER". - Never try to find frameworks.<br></pre>
    <p>On Darwin or systems supporting OSX Application Bundles, the
    cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of
    the following:<br>
    </p>
    <pre>   "FIRST"  - Try to find application bundles before standard<br>              programs. This is the default on Darwin.<br>   "LAST"   - Try to find application bundles after standard<br>              programs.<br>   "ONLY"   - Only try to find application bundles.<br>   "NEVER". - Never try to find application bundles.<br></pre>
    <p>The reason the paths listed in the call to the command are
    searched last is that most users of CMake would expect things to be
    found first in the locations specified by their environment.
    Projects may override this behavior by simply calling the command
    twice:<br>
    </p>
    <pre>   FIND_FILE(&lt;VAR&gt; NAMES name PATHS paths NO_DEFAULT_PATH)<br>   FIND_FILE(&lt;VAR&gt; NAMES name)<br></pre>
    <p>Once one of these calls succeeds the result variable will be
    set and stored in the cache so that neither call will search again.
    </p>
    </li>
    
    <li><b><code><a name="FIND_LIBRARY">FIND_LIBRARY</a></code></b>: Find a library.<br>
    <pre>   FIND_LIBRARY(&lt;VAR&gt; name1 path1 path2 ...)<br></pre>
    <p>This is the short-hand signature for the command that is
    sufficient in many cases. It is the same as FIND_LIBRARY(&lt;VAR&gt;
    name1 PATHS path2 path2 ...)<br>
    </p>
    <pre>   FIND_LIBRARY(<br>             &lt;VAR&gt; <br>             name | NAMES name1 [name2 ...]<br>             PATHS path1 [path2 ... ENV var]<br>             [PATH_SUFFIXES suffix1 [suffix2 ...]]<br>             [DOC "cache documentation string"]<br>             [NO_DEFAULT_PATH]<br>             [NO_CMAKE_ENVIRONMENT_PATH]<br>             [NO_CMAKE_PATH]<br>             [NO_SYSTEM_ENVIRONMENT_PATH]<br>             [NO_CMAKE_SYSTEM_PATH]<br>            )<br></pre>
    <p>This command is used to find a library. A cache entry named
    by &lt;VAR&gt; is created to store the result of this command. If
    the library is found the result is stored in the variable and the
    search will not be repeated unless the variable is cleared. If
    nothing is found, the result will be &lt;VAR&gt;-NOTFOUND, and the
    search will be attempted again the next time FIND_LIBRARY is invoked
    with the same variable. The name of the library that is searched for
    is specified by the names listed after the NAMES argument.
    Additional search locations can be specified after the PATHS
    argument. If ENV var is found in the PATHS section the environment
    variable var will be read and converted from a system environment
    variable to a cmake style list of paths. For example ENV PATH would
    be a way to list the system path variable. The argument after DOC
    will be used for the documentation string in the cache.
    PATH_SUFFIXES can be used to give sub directories that will be
    appended to the search paths.<br>
    </p>
    <p>If NO_DEFAULT_PATH is specified, then no additional paths are
    added to the search. If NO_DEFAULT_PATH is not specified, the search
    process is as follows:<br>
    </p>
    <p>1. Search cmake specific environment variables. This can be
    skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.<br>
    </p>
    <pre>   CMAKE_FRAMEWORK_PATH<br>   CMAKE_APPBUNDLE_PATH<br>   CMAKE_LIBRARY_PATH<br></pre>
    <p>2. Search cmake variables with the same names as the cmake
    specific environment variables. These are intended to be used on the
    command line with a -DVAR=value. This can be skipped if
    NO_CMAKE_PATH is passed.<br>
    </p>
    <pre>   CMAKE_FRAMEWORK_PATH<br>   CMAKE_APPBUNDLE_PATH<br>   CMAKE_LIBRARY_PATH<br></pre>
    <p>3. Search the standard system environment variables. This can
    be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.<br>
    </p>
    <pre>   PATH<br>   LIB<br></pre>
    <p>4. Search cmake variables defined in the Platform files for
    the current system. This can be skipped if NO_CMAKE_SYSTEM_PATH is
    passed.<br>
    </p>
    <pre>   CMAKE_SYSTEM_FRAMEWORK_PATH<br>   CMAKE_SYSTEM_APPBUNDLE_PATH<br>   CMAKE_SYSTEM_LIBRARY_PATH<br></pre>
    <p>5. Search the paths specified after PATHS or in the
    short-hand version of the command.<br>
    </p>
    <p>On Darwin or systems supporting OSX Frameworks, the cmake
    variable CMAKE_FIND_FRAMEWORK can be set to empty or one of the
    following:<br>
    </p>
    <pre>   "FIRST"  - Try to find frameworks before standard<br>              libraries or headers. This is the default on Darwin.<br>   "LAST"   - Try to find frameworks after standard<br>              libraries or headers.<br>   "ONLY"   - Only try to find frameworks.<br>   "NEVER". - Never try to find frameworks.<br></pre>
    <p>On Darwin or systems supporting OSX Application Bundles, the
    cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of
    the following:<br>
    </p>
    <pre>   "FIRST"  - Try to find application bundles before standard<br>              programs. This is the default on Darwin.<br>   "LAST"   - Try to find application bundles after standard<br>              programs.<br>   "ONLY"   - Only try to find application bundles.<br>   "NEVER". - Never try to find application bundles.<br></pre>
    <p>The reason the paths listed in the call to the command are
    searched last is that most users of CMake would expect things to be
    found first in the locations specified by their environment.
    Projects may override this behavior by simply calling the command
    twice:<br>
    </p>
    <pre>   FIND_LIBRARY(&lt;VAR&gt; NAMES name PATHS paths NO_DEFAULT_PATH)<br>   FIND_LIBRARY(&lt;VAR&gt; NAMES name)<br></pre>
    <p>Once one of these calls succeeds the result variable will be
    set and stored in the cache so that neither call will search again.<br>
    </p>
    <p>If the library found is a framework, then VAR will be set to
    the full path to the framework &lt;fullPath&gt;/A.framework. When a
    full path to a framework is used as a library, CMake will use a
    -framework A, and a -F&lt;fullPath&gt; to link the framework to the
    target.</p>
    </li>
    
    <li><b><code><a name="FIND_PACKAGE">FIND_PACKAGE</a></code></b>: Load settings for an
    external project.<br>
    <pre>  FIND_PACKAGE(&lt;name&gt; [major.minor] [QUIET] [NO_MODULE]<br>               [[REQUIRED|COMPONENTS] [componets...]])<br></pre>
    <p>Finds and loads settings from an external project.
    &lt;name&gt;_FOUND will be set to indicate whether the package was
    found. Settings that can be used when &lt;name&gt;_FOUND is true are
    package-specific. The package is found through several steps.
    Directories listed in CMAKE_MODULE_PATH are searched for files
    called "Find&lt;name&gt;.cmake". If such a file is found, it is read
    and processed by CMake, and is responsible for finding the package.
    This first step may be skipped by using the NO_MODULE option. If no
    such file is found, it is expected that the package is another
    project built by CMake that has a "&lt;name&gt;Config.cmake" file. A
    cache entry called &lt;name&gt;_DIR is created and is expected to be
    set to the directory containing this file. If the file is found, it
    is read and processed by CMake to load the settings of the package.
    If &lt;name&gt;_DIR has not been set during a configure step, the
    command will generate an error describing the problem unless the
    QUIET argument is specified. If &lt;name&gt;_DIR has been set to a
    directory not containing a "&lt;name&gt;Config.cmake" file, an error
    is always generated. If REQUIRED is specified and the package is not
    found, a FATAL_ERROR is generated and the configure step stops
    executing. A package-specific list of components may be listed after
    the REQUIRED option, or after the COMPONENTS option if no REQUIRED
    option is given.</p>
    </li>
    
    <li><b><code><a name="FIND_PATH">FIND_PATH</a></code></b>: Find the directory
    containing a file.<br>
    <pre>   FIND_PATH(&lt;VAR&gt; name1 path1 path2 ...)<br></pre>
    <p>This is the short-hand signature for the command that is
    sufficient in many cases. It is the same as FIND_PATH(&lt;VAR&gt;
    name1 PATHS path2 path2 ...)<br>
    </p>
    <pre>   FIND_PATH(<br>             &lt;VAR&gt; <br>             name | NAMES name1 [name2 ...]<br>             PATHS path1 [path2 ... ENV var]<br>             [PATH_SUFFIXES suffix1 [suffix2 ...]]<br>             [DOC "cache documentation string"]<br>             [NO_DEFAULT_PATH]<br>             [NO_CMAKE_ENVIRONMENT_PATH]<br>             [NO_CMAKE_PATH]<br>             [NO_SYSTEM_ENVIRONMENT_PATH]<br>             [NO_CMAKE_SYSTEM_PATH]<br>            )<br></pre>
    <p>This command is used to find a directory containing the named
    file. A cache entry named by &lt;VAR&gt; is created to store the
    result of this command. If the file in a directory is found the
    result is stored in the variable and the search will not be repeated
    unless the variable is cleared. If nothing is found, the result will
    be &lt;VAR&gt;-NOTFOUND, and the search will be attempted again the
    next time FIND_PATH is invoked with the same variable. The name of
    the file in a directory that is searched for is specified by the
    names listed after the NAMES argument. Additional search locations
    can be specified after the PATHS argument. If ENV var is found in
    the PATHS section the environment variable var will be read and
    converted from a system environment variable to a cmake style list
    of paths. For example ENV PATH would be a way to list the system
    path variable. The argument after DOC will be used for the
    documentation string in the cache. PATH_SUFFIXES can be used to give
    sub directories that will be appended to the search paths.<br>
    </p>
    <p>If NO_DEFAULT_PATH is specified, then no additional paths are
    added to the search. If NO_DEFAULT_PATH is not specified, the search
    process is as follows:<br>
    </p>
    <p>1. Search cmake specific environment variables. This can be
    skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.<br>
    </p>
    <pre>   CMAKE_FRAMEWORK_PATH<br>   CMAKE_APPBUNDLE_PATH<br>   CMAKE_INCLUDE_PATH<br></pre>
    <p>2. Search cmake variables with the same names as the cmake
    specific environment variables. These are intended to be used on the
    command line with a -DVAR=value. This can be skipped if
    NO_CMAKE_PATH is passed.<br>
    </p>
    <pre>   CMAKE_FRAMEWORK_PATH<br>   CMAKE_APPBUNDLE_PATH<br>   CMAKE_INCLUDE_PATH<br></pre>
    <p>3. Search the standard system environment variables. This can
    be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.<br>
    </p>
    <pre>   PATH<br>   INCLUDE<br></pre>
    <p>4. Search cmake variables defined in the Platform files for
    the current system. This can be skipped if NO_CMAKE_SYSTEM_PATH is
    passed.<br>
    </p>
    <pre>   CMAKE_SYSTEM_FRAMEWORK_PATH<br>   CMAKE_SYSTEM_APPBUNDLE_PATH<br>   CMAKE_SYSTEM_INCLUDE_PATH<br></pre>
    <p>5. Search the paths specified after PATHS or in the
    short-hand version of the command.<br>
    </p>
    <p>On Darwin or systems supporting OSX Frameworks, the cmake
    variable CMAKE_FIND_FRAMEWORK can be set to empty or one of the
    following:<br>
    </p>
    <pre>   "FIRST"  - Try to find frameworks before standard<br>              libraries or headers. This is the default on Darwin.<br>   "LAST"   - Try to find frameworks after standard<br>              libraries or headers.<br>   "ONLY"   - Only try to find frameworks.<br>   "NEVER". - Never try to find frameworks.<br></pre>
    <p>On Darwin or systems supporting OSX Application Bundles, the
    cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of
    the following:<br>
    </p>
    <pre>   "FIRST"  - Try to find application bundles before standard<br>              programs. This is the default on Darwin.<br>   "LAST"   - Try to find application bundles after standard<br>              programs.<br>   "ONLY"   - Only try to find application bundles.<br>   "NEVER". - Never try to find application bundles.<br></pre>
    <p>The reason the paths listed in the call to the command are
    searched last is that most users of CMake would expect things to be
    found first in the locations specified by their environment.
    Projects may override this behavior by simply calling the command
    twice:<br>
    </p>
    <pre>   FIND_PATH(&lt;VAR&gt; NAMES name PATHS paths NO_DEFAULT_PATH)<br>   FIND_PATH(&lt;VAR&gt; NAMES name)<br></pre>
    <p>Once one of these calls succeeds the result variable will be
    set and stored in the cache so that neither call will search again.<br>
    </p>
    <p>When searching for frameworks, if the file is specified as
    A/b.h, then the framework search will look for
    A.framework/Headers/b.h. If that is found the path will be set to
    the path to the framework. CMake will convert this to the correct -F
    option to include the file.</p>
    </li>
    
    <li><b><code><a name="FIND_PROGRAM">FIND_PROGRAM</a></code></b>: Find an executable
    program.<br>
    <pre>   FIND_PROGRAM(&lt;VAR&gt; name1 path1 path2 ...)<br></pre>
    <p>This is the short-hand signature for the command that is
    sufficient in many cases. It is the same as FIND_PROGRAM(&lt;VAR&gt;
    name1 PATHS path2 path2 ...)<br>
    </p>
    <pre>   FIND_PROGRAM(<br>             &lt;VAR&gt; <br>             name | NAMES name1 [name2 ...]<br>             PATHS path1 [path2 ... ENV var]<br>             [PATH_SUFFIXES suffix1 [suffix2 ...]]<br>             [DOC "cache documentation string"]<br>             [NO_DEFAULT_PATH]<br>             [NO_CMAKE_ENVIRONMENT_PATH]<br>             [NO_CMAKE_PATH]<br>             [NO_SYSTEM_ENVIRONMENT_PATH]<br>             [NO_CMAKE_SYSTEM_PATH]<br>            )<br></pre>
    <p>This command is used to find a program. A cache entry named
    by &lt;VAR&gt; is created to store the result of this command. If
    the program is found the result is stored in the variable and the
    search will not be repeated unless the variable is cleared. If
    nothing is found, the result will be &lt;VAR&gt;-NOTFOUND, and the
    search will be attempted again the next time FIND_PROGRAM is invoked
    with the same variable. The name of the program that is searched for
    is specified by the names listed after the NAMES argument.
    Additional search locations can be specified after the PATHS
    argument. If ENV var is found in the PATHS section the environment
    variable var will be read and converted from a system environment
    variable to a cmake style list of paths. For example ENV PATH would
    be a way to list the system path variable. The argument after DOC
    will be used for the documentation string in the cache.
    PATH_SUFFIXES can be used to give sub directories that will be
    appended to the search paths.<br>
    </p>
    <p>If NO_DEFAULT_PATH is specified, then no additional paths are
    added to the search. If NO_DEFAULT_PATH is not specified, the search
    process is as follows:<br>
    </p>
    <p>1. Search cmake specific environment variables. This can be
    skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.<br>
    </p>
    <pre>   CMAKE_FRAMEWORK_PATH<br>   CMAKE_APPBUNDLE_PATH<br>   CMAKE_PROGRAM_PATH<br></pre>
    <p>2. Search cmake variables with the same names as the cmake
    specific environment variables. These are intended to be used on the
    command line with a -DVAR=value. This can be skipped if
    NO_CMAKE_PATH is passed.<br>
    </p>
    <pre>   CMAKE_FRAMEWORK_PATH<br>   CMAKE_APPBUNDLE_PATH<br>   CMAKE_PROGRAM_PATH<br></pre>
    <p>3. Search the standard system environment variables. This can
    be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.<br>
    </p>
    <pre>   PATH<br>   <br></pre>
    <p>4. Search cmake variables defined in the Platform files for
    the current system. This can be skipped if NO_CMAKE_SYSTEM_PATH is
    passed.<br>
    </p>
    <pre>   CMAKE_SYSTEM_FRAMEWORK_PATH<br>   CMAKE_SYSTEM_APPBUNDLE_PATH<br>   CMAKE_SYSTEM_PROGRAM_PATH<br></pre>
    <p>5. Search the paths specified after PATHS or in the
    short-hand version of the command.<br>
    </p>
    <p>On Darwin or systems supporting OSX Frameworks, the cmake
    variable CMAKE_FIND_FRAMEWORK can be set to empty or one of the
    following:<br>
    </p>
    <pre>   "FIRST"  - Try to find frameworks before standard<br>              libraries or headers. This is the default on Darwin.<br>   "LAST"   - Try to find frameworks after standard<br>              libraries or headers.<br>   "ONLY"   - Only try to find frameworks.<br>   "NEVER". - Never try to find frameworks.<br></pre>
    <p>On Darwin or systems supporting OSX Application Bundles, the
    cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of
    the following:<br>
    </p>
    <pre>   "FIRST"  - Try to find application bundles before standard<br>              programs. This is the default on Darwin.<br>   "LAST"   - Try to find application bundles after standard<br>              programs.<br>   "ONLY"   - Only try to find application bundles.<br>   "NEVER". - Never try to find application bundles.<br></pre>
    <p>The reason the paths listed in the call to the command are
    searched last is that most users of CMake would expect things to be
    found first in the locations specified by their environment.
    Projects may override this behavior by simply calling the command
    twice:<br>
    </p>
    <pre>   FIND_PROGRAM(&lt;VAR&gt; NAMES name PATHS paths NO_DEFAULT_PATH)<br>   FIND_PROGRAM(&lt;VAR&gt; NAMES name)<br></pre>
    <p>Once one of these calls succeeds the result variable will be
    set and stored in the cache so that neither call will search again.
    </p>
    </li>
    
    <li><b><code><a name="FLTK_WRAP_UI">FLTK_WRAP_UI</a></code></b>: Create FLTK user
    interfaces Wrappers.<br>
    <pre>  FLTK_WRAP_UI(resultingLibraryName source1<br>               source2 ... sourceN )<br></pre>
    <p>Produce .h and .cxx files for all the .fl and .fld files
    listed. The resulting .h and .cxx files will be added to a variable
    named resultingLibraryName_FLTK_UI_SRCS which should be added to
    your library.</p>
    </li>
    
    <li><b><code><a name="FOREACH">FOREACH</a></code></b>: Evaluate a group of commands
    for each value in a list.<br>
    <pre>  FOREACH(loop_var arg1 arg2 ...)<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  ENDFOREACH(loop_var)<br>  FOREACH(loop_var RANGE total)<br>  FOREACH(loop_var RANGE start stop [step])<br></pre>
    <p>All commands between FOREACH and the matching ENDFOREACH are
    recorded without being invoked. Once the ENDFOREACH is evaluated,
    the recorded list of commands is invoked once for each argument
    listed in the original FOREACH command. Before each iteration of the
    loop "${loop_var}" will be set as a variable with the current value
    in the list.<br>
    </p>
    <p>Foreach can also iterate over a generated range of numbers.
    There are three types of this iteration:<br>
    </p>
    <p>* When specifying single number, the range will have elements
    0 to "total".<br>
    </p>
    <p>* When specifying two numbers, the range will have elements
    from the first number to the second number.<br>
    </p>
    <p>* The third optional number is the increment used to iterate
    from the first number to the second number.</p>
    </li>
    
    <li><b><code><a name="GET_CMAKE_PROPERTY">GET_CMAKE_PROPERTY</a></code></b>: Get a property of
    the CMake instance.<br>
    <pre>  GET_CMAKE_PROPERTY(VAR property)<br></pre>
    <p>Get a property from the CMake instance. The value of the
    property is stored in the variable VAR. If the property is not
    found, CMake will report an error. Some supported properties
    include: VARIABLES, CACHE_VARIABLES, COMMANDS, and MACROS.</p>
    </li>
    
    <li><b><code><a name="GET_DIRECTORY_PROPERTY">GET_DIRECTORY_PROPERTY</a></code></b>: Get a property
    of the directory.<br>
    <pre>  GET_DIRECTORY_PROPERTY(VAR [DIRECTORY dir] property)<br></pre>
    <p>Get a property from the Directory. The value of the property
    is stored in the variable VAR. If the property is not found, CMake
    will report an error. The properties include: VARIABLES,
    CACHE_VARIABLES, COMMANDS, MACROS, INCLUDE_DIRECTORIES,
    LINK_DIRECTORIES, DEFINITIONS, INCLUDE_REGULAR_EXPRESSION,
    LISTFILE_STACK, PARENT_DIRECTORY, and DEFINITION varname. If the
    DIRECTORY argument is provided then the property of the provided
    directory will be retrieved instead of the current directory. You
    can only get properties of a directory during or after it has been
    traversed by cmake.</p>
    </li>
    
    <li><b><code><a name="GET_FILENAME_COMPONENT">GET_FILENAME_COMPONENT</a></code></b>: Get a specific
    component of a full filename.<br>
    <pre>  GET_FILENAME_COMPONENT(VarName FileName<br>                         PATH|ABSOLUTE|NAME|EXT|NAME_WE<br>                         [CACHE])<br></pre>
    <p>Set VarName to be the path (PATH), file name (NAME), file
    extension (EXT), file name without extension (NAME_WE) of FileName,
    or the full absolute (ABSOLUTE) file name without symlinks. Note
    that the path is converted to Unix slashes format and has no
    trailing slashes. The longest file extension is always considered.
    If the optional CACHE argument is specified, the result variable is
    added to the cache.<br>
    </p>
    <pre>  GET_FILENAME_COMPONENT(VarName FileName<br>                         PROGRAM [PROGRAM_ARGS ArgVar]<br>                         [CACHE])<br></pre>
    <p>The program in FileName will be found in the system search
    path or left as a full path. If PROGRAM_ARGS is present with
    PROGRAM, then any command-line arguments present in the FileName
    string are split from the program name and stored in ArgVar. This is
    used to separate a program name from its arguments in a command line
    string.</p>
    </li>
    
    <li><b><code><a name="GET_SOURCE_FILE_PROPERTY">GET_SOURCE_FILE_PROPERTY</a></code></b>: Get a
    property for a source file.<br>
    <pre>  GET_SOURCE_FILE_PROPERTY(VAR file property)<br></pre>
    <p>Get a property from a source file. The value of the property
    is stored in the variable VAR. If the property is not found, VAR
    will be set to "NOTFOUND". Use SET_SOURCE_FILES_PROPERTIES to set
    property values. Source file properties usually control how the file
    is built. One property that is always there is LOCATION</p>
    </li>
    
    <li><b><code><a name="GET_TARGET_PROPERTY">GET_TARGET_PROPERTY</a></code></b>: Get a property
    from a target.<br>
    <pre>  GET_TARGET_PROPERTY(VAR target property)<br></pre>
    <p>Get a property from a target. The value of the property is
    stored in the variable VAR. If the property is not found, VAR will
    be set to "NOTFOUND". Use SET_TARGET_PROPERTIES to set property
    values. Properties are usually used to control how a target is
    built.<br>
    </p>
    <p>The read-only property "&lt;CONFIG&gt;_LOCATION" provides the
    full path to the file on disk that will be created for the target
    when building under configuration &lt;CONFIG&gt; (in upper-case,
    such as "DEBUG_LOCATION"). The read-only property "LOCATION"
    specifies the full path to the file on disk that will be created for
    the target. The path may contain a build-system-specific portion
    that is replaced at build time with the configuration getting built
    (such as "$(ConfigurationName)" in VS). This is very useful for
    executable targets to get the path to the executable file for use in
    a custom command.<br>
    </p>
    <p>The read-only property "TYPE" returns which type the
    specified target has (EXECUTABLE, STATIC_LIBRARY, SHARED_LIBRARY,
    MODULE_LIBRARY, UTILITY, INSTALL_FILES or INSTALL_PROGRAMS). This
    command can get properties for any target so far created. The
    targets do not need to be in the current CMakeLists.txt file.</p>
    </li>
    
    <li><b><code><a name="GET_TEST_PROPERTY">GET_TEST_PROPERTY</a></code></b>: Get a property of
    the test.<br>
    <pre>  GET_TEST_PROPERTY(test VAR property)<br></pre>
    <p>Get a property from the Test. The value of the property is
    stored in the variable VAR. If the property is not found, CMake will
    report an error.</p>
    </li>
    
    <li><b><code><a name="IF">IF</a></code></b>: Conditionally execute a group of
    commands.<br>
    <pre>  IF(expression)<br>    # THEN section.<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  ELSE(expression)<br>    # ELSE section.<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  ENDIF(expression)<br></pre>
    <p>Evaluates the given expression. If the result is true, the
    commands in the THEN section are invoked. Otherwise, the commands in
    the ELSE section are invoked. The ELSE section is optional. Note
    that the same expression must be given to IF, ELSE, and ENDIF. Long
    expressions can be used and the order or precedence is that the
    EXISTS, COMMAND, and DEFINED operators will be evaluated first. Then
    any EQUAL, LESS, GREATER, STRLESS, STRGREATER, STREQUAL, MATCHES
    will be evaluated. Then NOT operators and finally AND, OR operators
    will be evaluated. Possible expressions are:<br>
    </p>
    <pre>  IF(variable)<br></pre>
    <p>True if the variable's value is not empty, 0, N, NO, OFF,
    FALSE, NOTFOUND, or &lt;variable&gt;-NOTFOUND.<br>
    </p>
    <pre>  IF(NOT variable)<br></pre>
    <p>True if the variable's value is empty, 0, N, NO, OFF, FALSE,
    NOTFOUND, or &lt;variable&gt;-NOTFOUND.<br>
    </p>
    <pre>  IF(variable1 AND variable2)<br></pre>
    <p>True if both variables would be considered true individually.<br>
    </p>
    <pre>  IF(variable1 OR variable2)<br></pre>
    <p>True if either variable would be considered true
    individually.<br>
    </p>
    <pre>  IF(COMMAND command-name)<br></pre>
    <p>True if the given name is a command that can be invoked.<br>
    </p>
    <pre>  IF(EXISTS file-name)<br>  IF(EXISTS directory-name)<br></pre>
    <p>True if the named file or directory exists. Behavior is
    well-defined only for full paths.<br>
    </p>
    <pre>  IF(file1 IS_NEWER_THAN file2)<br></pre>
    <p>True if file1 is newer than file2 or if one of the two files
    doesn't exist. Behavior is well-defined only for full paths.<br>
    </p>
    <pre>  IF(IS_DIRECTORY directory-name)<br></pre>
    <p>True if the given name is a directory. Behavior is
    well-defined only for full paths.<br>
    </p>
    <pre>  IF(variable MATCHES regex)<br>  IF(string MATCHES regex)<br></pre>
    <p>True if the given string or variable's value matches the
    given regular expression.<br>
    </p>
    <pre>  IF(variable LESS number)<br>  IF(string LESS number)<br>  IF(variable GREATER number)<br>  IF(string GREATER number)<br>  IF(variable EQUAL number)<br>  IF(string EQUAL number)<br></pre>
    <p>True if the given string or variable's value is a valid
    number and the inequality or equality is true.<br>
    </p>
    <pre>  IF(variable STRLESS string)<br>  IF(string STRLESS string)<br>  IF(variable STRGREATER string)<br>  IF(string STRGREATER string)<br>  IF(variable STREQUAL string)<br>  IF(string STREQUAL string)<br></pre>
    <p>True if the given string or variable's value is
    lexicographically less (or greater, or equal) than the string on the
    right.<br>
    </p>
    <pre>  IF(DEFINED variable)<br></pre>
    <p>True if the given variable is defined. It does not matter if
    the variable is true or false just if it has been set.</p>
    </li>
    
    <li><b><code><a name="INCLUDE">INCLUDE</a></code></b>: Read CMake listfile code from
    the given file.<br>
    <pre>  INCLUDE(file1 [OPTIONAL])<br>  INCLUDE(module [OPTIONAL])<br></pre>
    <p>Reads CMake listfile code from the given file. Commands in
    the file are processed immediately as if they were written in place
    of the INCLUDE command. If OPTIONAL is present, then no error is
    raised if the file does not exist.<br>
    </p>
    <p>If a module is specified instead of a file, the file with
    name &lt;modulename&gt;.cmake is searched in the CMAKE_MODULE_PATH.
    </p>
    </li>
    
    <li><b><code><a name="INCLUDE_DIRECTORIES">INCLUDE_DIRECTORIES</a></code></b>: Add include
    directories to the build.<br>
    <pre>  INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)<br></pre>
    <p>Add the given directories to those searched by the compiler
    for include files. By default the directories are appended onto the
    current list of directories. This default behavior can be changed by
    setting CMAKE_INCLUDE_DIRECTORIES_BEFORE to ON. By using BEFORE or
    AFTER you can select between appending and prepending, independent
    from the default. If the SYSTEM option is given the compiler will be
    told that the directories are meant as system include directories on
    some platforms.</p>
    </li>
    
    <li><b><code><a name="INCLUDE_EXTERNAL_MSPROJECT">INCLUDE_EXTERNAL_MSPROJECT</a></code></b>: Include an
    external Microsoft project file in a workspace.<br>
    <pre>  INCLUDE_EXTERNAL_MSPROJECT(projectname location<br>                             dep1 dep2 ...)<br></pre>
    <p>Includes an external Microsoft project in the generated
    workspace file. Currently does nothing on UNIX.</p>
    </li>
    
    <li><b><code><a name="INCLUDE_REGULAR_EXPRESSION">INCLUDE_REGULAR_EXPRESSION</a></code></b>: Set the
    regular expression used for dependency checking.<br>
    <pre>  INCLUDE_REGULAR_EXPRESSION(regex_match [regex_complain])<br></pre>
    <p>Set the regular expressions used in dependency checking. Only
    files matching regex_match will be traced as dependencies. Only
    files matching regex_complain will generate warnings if they cannot
    be found (standard header paths are not searched). The defaults are:<br>
    </p>
    <pre>  regex_match    = "^.*$" (match everything)<br>  regex_complain = "^$" (match empty string only)</pre>

    </li>
    
    <li><b><code><a name="INSTALL">INSTALL</a></code></b>: Specify rules to run at
    install time.<br>
    <p>This command generates installation rules for a project.
    Rules specified by calls to this command within a source directory
    are executed in order during installation. The order across
    directories is not defined.<br>
    </p>
    <p>There are multiple signatures for this command. Some of them
    define installation properties for files and targets. Properties
    common to multiple signatures are covered here but they are valid
    only for signatures that specify them. DESTINATION arguments specify
    the directory on disk to which a file will be installed. If a full
    path (with a leading slash or drive letter) is given it is used
    directly. If a relative path is given it is interpreted relative to
    the value of CMAKE_INSTALL_PREFIX. PERMISSIONS arguments specify
    permissions for installed files. Valid permissions are OWNER_READ,
    OWNER_WRITE, OWNER_EXECUTE, GROUP_READ, GROUP_WRITE, GROUP_EXECUTE,
    WORLD_READ, WORLD_WRITE, WORLD_EXECUTE, SETUID, and SETGID.
    Permissions that do not make sense on certain platforms are ignored
    on those platforms. The CONFIGURATIONS argument specifies a list of
    build configurations for which the install rule applies (Debug,
    Release, etc.). The COMPONENT argument specifies an installation
    component name with which the install rule is associated, such as
    "runtime" or "development". During component-specific installation
    only install rules associated with the given component name will be
    executed. During a full installation all components are installed.
    The RENAME argument specifies a name for an installed file that may
    be different from the original file. Renaming is allowed only when a
    single file is installed by the command. The OPTIONAL argument
    specifies that it is not an error if the file to be installed does
    not exist. <br>
    </p>
    <p>The TARGETS signature:<br>
    </p>
    <pre>  INSTALL(TARGETS targets...<br>          [[ARCHIVE|LIBRARY|RUNTIME]<br>                              [DESTINATION &lt;dir&gt;]<br>                              [PERMISSIONS permissions...]<br>                              [CONFIGURATIONS [Debug|Release|...]]<br>                              [COMPONENT &lt;component&gt;]<br>                              [OPTIONAL]<br>                             ] [...])<br></pre>
    <p>The TARGETS form specifies rules for installing targets from
    a project. There are three kinds of target files that may be
    installed: archive, library, and runtime. Executables are always
    treated as runtime targets. Static libraries are always treated as
    archive targets. Module libraries are always treated as library
    targets. For non-DLL platforms shared libraries are treated as
    library targets. For DLL platforms the DLL part of a shared library
    is treated as a runtime target and the corresponding import library
    is treated as an archive target. All Windows-based systems including
    Cygwin are DLL platforms. The ARCHIVE, LIBRARY, and RUNTIME
    arguments change the type of target to which the subsequent
    properties apply. If none is given the installation properties apply
    to all target types. If only one is given then only targets of that
    type will be installed (which can be used to install just a DLL or
    just an import library).<br>
    </p>
    <p>One or more groups of properties may be specified in a single
    call to the TARGETS form of this command. A target may be installed
    more than once to different locations. Consider hypothetical targets
    "myExe", "mySharedLib", and "myStaticLib". The code<br>
    </p>
    <pre>    INSTALL(TARGETS myExe mySharedLib myStaticLib<br>            RUNTIME DESTINATION bin<br>            LIBRARY DESTINATION lib<br>            ARCHIVE DESTINATION lib/static)<br>    INSTALL(TARGETS mySharedLib DESTINATION /some/full/path)<br></pre>
    <p>will install myExe to &lt;prefix&gt;/bin and myStaticLib to
    &lt;prefix&gt;/lib/static. On non-DLL platforms mySharedLib will be
    installed to &lt;prefix&gt;/lib and /some/full/path. On DLL
    platforms the mySharedLib DLL will be installed to
    &lt;prefix&gt;/bin and /some/full/path and its import library will
    be installed to &lt;prefix&gt;/lib/static and /some/full/path. On
    non-DLL platforms mySharedLib will be installed to
    &lt;prefix&gt;/lib and /some/full/path.<br>
    </p>
    <p>The FILES signature:<br>
    </p>
    <pre>  INSTALL(FILES files... DESTINATION &lt;dir&gt;<br>          [PERMISSIONS permissions...]<br>          [CONFIGURATIONS [Debug|Release|...]]<br>          [COMPONENT &lt;component&gt;]<br>          [RENAME &lt;name&gt;] [OPTIONAL])<br></pre>
    <p>The FILES form specifies rules for installing files for a
    project. File names given as relative paths are interpreted with
    respect to the current source directory. Files installed by this
    form are by default given permissions OWNER_WRITE, OWNER_READ,
    GROUP_READ, and WORLD_READ if no PERMISSIONS argument is given.<br>
    </p>
    <p>The PROGRAMS signature:<br>
    </p>
    <pre>  INSTALL(PROGRAMS files... DESTINATION &lt;dir&gt;<br>          [PERMISSIONS permissions...]<br>          [CONFIGURATIONS [Debug|Release|...]]<br>          [COMPONENT &lt;component&gt;]<br>          [RENAME &lt;name&gt;] [OPTIONAL])<br></pre>
    <p>The PROGRAMS form is identical to the FILES form except that
    the default permissions for the installed file also include
    OWNER_EXECUTE, GROUP_EXECUTE, and WORLD_EXECUTE. This form is
    intended to install programs that are not targets, such as shell
    scripts. Use the TARGETS form to install targets built within the
    project.<br>
    </p>
    <p>The DIRECTORY signature:<br>
    </p>
    <pre>  INSTALL(DIRECTORY dirs... DESTINATION &lt;dir&gt;<br>          [FILE_PERMISSIONS permissions...]<br>          [DIRECTORY_PERMISSIONS permissions...]<br>          [USE_SOURCE_PERMISSIONS]<br>          [CONFIGURATIONS [Debug|Release|...]]<br>          [COMPONENT &lt;component&gt;]<br>          [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]<br>           [EXCLUDE] [PERMISSIONS permissions...]] [...])<br></pre>
    <p>The DIRECTORY form installs contents of one or more
    directories to a given destination. The directory structure is
    copied verbatim to the destination. The last component of each
    directory name is appended to the destination directory but a
    trailing slash may be used to avoid this because it leaves the last
    component empty. Directory names given as relative paths are
    interpreted with respect to the current source directory. If no
    input directory names are given the destination directory will be
    created but nothing will be installed into it. The FILE_PERMISSIONS
    and DIRECTORY_PERMISSIONS options specify permissions given to files
    and directories in the destination. If USE_SOURCE_PERMISSIONS is
    specified and FILE_PERMISSIONS is not, file permissions will be
    copied from the source directory structure. If no permissions are
    specified files will be given the default permissions specified in
    the FILES form of the command, and the directories will be given the
    default permissions specified in the PROGRAMS form of the command.
    The PATTERN and REGEX options specify a globbing pattern or regular
    expression to match directories or files encountered during
    traversal of an input directory. The full path to an input file or
    directory (with forward slashes) is matched against the expression.
    A PATTERN will match only complete file names: the portion of the
    full path matching the pattern must occur at the end of the file
    name and be preceded by a slash. A REGEX will match any portion of
    the full path but it may use '/' and '$' to simulate the PATTERN
    behavior. Options following one of these matching expressions are
    applied only to files or directories matching them. The EXCLUDE
    option will skip the matched file or directory. The PERMISSIONS
    option overrides the permissions setting for the matched file or
    directory. For example the code<br>
    </p>
    <pre>  INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj<br>          PATTERN "CVS" EXCLUDE<br>          PATTERN "scripts/*"<br>          PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ<br>                      GROUP_EXECUTE GROUP_READ)<br></pre>
    <p>will install the icons directory to share/myproj/icons and
    the scripts directory to share/myproj. The icons will get default
    file permissions, the scripts will be given specific permissions,
    and any CVS directories will be excluded.<br>
    </p>
    <p>The SCRIPT and CODE signature:<br>
    </p>
    <pre>  INSTALL([[SCRIPT &lt;file&gt;] [CODE &lt;code&gt;]] [...])<br></pre>
    <p>The SCRIPT form will invoke the given CMake script files
    during installation. If the script file name is a relative path it
    will be interpreted with respect to the current source directory.
    The CODE form will invoke the given CMake code during installation.
    Code is specified as a single argument inside a double-quoted
    string. For example, the code<br>
    </p>
    <pre>  INSTALL(CODE "MESSAGE(\"Sample install message.\")")<br></pre>
    <p>will print a message during installation.<br>
    </p>
    <p>NOTE: This command supercedes the INSTALL_TARGETS command and
    the target properties PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT. It
    also replaces the FILES forms of the INSTALL_FILES and
    INSTALL_PROGRAMS commands. The processing order of these install
    rules relative to those generated by INSTALL_TARGETS, INSTALL_FILES,
    and INSTALL_PROGRAMS commands is not defined.<br>
    </p>
    </li>
    
    <li><b><code><a name="INSTALL_FILES">INSTALL_FILES</a></code></b>: Old installation
    command. Use the INSTALL command.<br>
    <p>This command has been superceded by the INSTALL command. It
    is provided for compatibility with older CMake code. The FILES form
    is directly replaced by the FILES form of the INSTALL command. The
    regexp form can be expressed more clearly using the GLOB form of the
    FILE command.<br>
    </p>
    <pre>  INSTALL_FILES(&lt;dir&gt; extension file file ...)<br></pre>
    <p>Create rules to install the listed files with the given
    extension into the given directory. Only files existing in the
    current source tree or its corresponding location in the binary tree
    may be listed. If a file specified already has an extension, that
    extension will be removed first. This is useful for providing lists
    of source files such as foo.cxx when you want the corresponding
    foo.h to be installed. A typical extension is '.h'.<br>
    </p>
    <pre>  INSTALL_FILES(&lt;dir&gt; regexp)<br></pre>
    <p>Any files in the current source directory that match the
    regular expression will be installed.<br>
    </p>
    <pre>  INSTALL_FILES(&lt;dir&gt; FILES file file ...)<br></pre>
    <p>Any files listed after the FILES keyword will be installed
    explicitly from the names given. Full paths are allowed in this
    form.<br>
    </p>
    <p>The directory &lt;dir&gt; is relative to the installation
    prefix, which is stored in the variable CMAKE_INSTALL_PREFIX.</p>
    </li>
    
    <li><b><code><a name="INSTALL_PROGRAMS">INSTALL_PROGRAMS</a></code></b>: Old installation
    command. Use the INSTALL command.<br>
    <p>This command has been superceded by the INSTALL command. It
    is provided for compatibility with older CMake code. The FILES form
    is directly replaced by the PROGRAMS form of the INSTALL command.
    The regexp form can be expressed more clearly using the GLOB form of
    the FILE command.<br>
    </p>
    <pre>  INSTALL_PROGRAMS(&lt;dir&gt; file1 file2 [file3 ...])<br>  INSTALL_PROGRAMS(&lt;dir&gt; FILES file1 [file2 ...])<br></pre>
    <p>Create rules to install the listed programs into the given
    directory. Use the FILES argument to guarantee that the file list
    version of the command will be used even when there is only one
    argument.<br>
    </p>
    <pre>  INSTALL_PROGRAMS(&lt;dir&gt; regexp)<br></pre>
    <p>In the second form any program in the current source
    directory that matches the regular expression will be installed.<br>
    </p>
    <p>This command is intended to install programs that are not
    built by cmake, such as shell scripts. See the TARGETS form of the
    INSTALL command to create installation rules for targets built by
    cmake.<br>
    </p>
    <p>The directory &lt;dir&gt; is relative to the installation
    prefix, which is stored in the variable CMAKE_INSTALL_PREFIX.</p>
    </li>
    
    <li><b><code><a name="INSTALL_TARGETS">INSTALL_TARGETS</a></code></b>: Old installation
    command. Use the INSTALL command.<br>
    <p>This command has been superceded by the INSTALL command. It
    is provided for compatibility with older CMake code.<br>
    </p>
    <pre>  INSTALL_TARGETS(&lt;dir&gt; [RUNTIME_DIRECTORY dir] target target)<br></pre>
    <p>Create rules to install the listed targets into the given
    directory. The directory &lt;dir&gt; is relative to the installation
    prefix, which is stored in the variable CMAKE_INSTALL_PREFIX. If
    RUNTIME_DIRECTORY is specified, then on systems with special runtime
    files (Windows DLL), the files will be copied to that directory.</p>
    </li>
    
    <li><b><code><a name="LINK_DIRECTORIES">LINK_DIRECTORIES</a></code></b>: Specify directories
    in which to search for libraries.<br>
    <pre>  LINK_DIRECTORIES(directory1 directory2 ...)<br></pre>
    <p>Specify the paths in which the linker should search for
    libraries.</p>
    </li>
    
    <li><b><code><a name="LINK_LIBRARIES">LINK_LIBRARIES</a></code></b>: Link libraries to all
    targets added later.<br>
    <pre>  LINK_LIBRARIES(library1 &lt;debug | optimized&gt; library2 ...)<br></pre>
    <p>This is an old CMake command for linking libraries. Use
    TARGET_LINK_LIBRARIES unless you have a good reason for every target
    to link to the same set of libraries.<br>
    </p>
    <p>Specify a list of libraries to be linked into any following
    targets (typically added with the ADD_EXECUTABLE or ADD_LIBRARY
    calls). This command is passed down to all subdirectories. The debug
    and optimized strings may be used to indicate that the next library
    listed is to be used only for that specific type of build.</p>
    </li>
    
    <li><b><code><a name="LIST">LIST</a></code></b>: List operations.<br>
    <pre>  LIST(LENGTH &lt;list&gt; &lt;output variable&gt;)<br>  LIST(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)<br>  LIST(APPEND &lt;list&gt; &lt;element&gt; [&lt;element&gt; ...])<br>  LIST(INSERT &lt;list&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])<br>  LIST(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])<br>  LIST(REMOVE_AT &lt;list&gt; &lt;index&gt; [&lt;index&gt; ...])<br>  LIST(SORT &lt;list&gt;)<br>  LIST(REVERSE &lt;list&gt;)<br></pre>
    <p>LENGTH will return a given list's length.<br>
    </p>
    <p>GET will return list of elements specified by indices from
    the list.<br>
    </p>
    <p>APPEND will append elements to the list.<br>
    </p>
    <p>INSERT will insert elements to the list to the specified
    location.<br>
    </p>
    <p>When specifying an index, negative value corresponds to index
    from the end of the list.<br>
    </p>
    <p>REMOVE_AT and REMOVE_ITEM will remove item from the list. The
    difference is that REMOVE_ITEM will remove the given items, while
    REMOVE_AT will remove the item at the given indices.<br>
    </p>
    </li>
    
    <li><b><code><a name="LOAD_CACHE">LOAD_CACHE</a></code></b>: Load in the values from
    another project's CMake cache.<br>
    <pre>  LOAD_CACHE(pathToCacheFile READ_WITH_PREFIX<br>             prefix entry1...)<br></pre>
    <p>Read the cache and store the requested entries in variables
    with their name prefixed with the given prefix. This only reads the
    values, and does not create entries in the local project's cache.<br>
    </p>
    <pre>  LOAD_CACHE(pathToCacheFile [EXCLUDE entry1...]<br>             [INCLUDE_INTERNALS entry1...])<br></pre>
    <p>Load in the values from another cache and store them in the
    local project's cache as internal entries. This is useful for a
    project that depends on another project built in a different tree.
    EXCLUDE option can be used to provide a list of entries to be
    excluded. INCLUDE_INTERNALS can be used to provide a list of
    internal entries to be included. Normally, no internal entries are
    brought in. Use of this form of the command is strongly discouraged,
    but it is provided for backward compatibility.</p>
    </li>
    
    <li><b><code><a name="LOAD_COMMAND">LOAD_COMMAND</a></code></b>: Load a command into a
    running CMake.<br>
    <pre>  LOAD_COMMAND(COMMAND_NAME &lt;loc1&gt; [loc2 ...])<br></pre>
    <p>The given locations are searched for a library whose name is
    cmCOMMAND_NAME. If found, it is loaded as a module and the command
    is added to the set of available CMake commands. Usually,
    TRY_COMPILE is used before this command to compile the module. If
    the command is successfully loaded a variable named<br>
    </p>
    <pre>  CMAKE_LOADED_COMMAND_&lt;COMMAND_NAME&gt;<br></pre>
    <p>will be set to the full path of the module that was loaded.
    Otherwise the variable will not be set.</p>
    </li>
    
    <li><b><code><a name="MACRO">MACRO</a></code></b>: Start recording a macro for
    later invocation as a command.<br>
    <pre>  MACRO(&lt;name&gt; [arg1 [arg2 [arg3 ...]]])<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  ENDMACRO(&lt;name&gt;)<br></pre>
    <p>Define a macro named &lt;name&gt; that takes arguments named
    arg1 arg2 arg3 (...). Commands listed after MACRO, but before the
    matching ENDMACRO, are not invoked until the macro is invoked. When
    it is invoked, the commands recorded in the macro are first modified
    by replacing formal parameters (${arg1}) with the arguments passed,
    and then invoked as normal commands. In addition to referencing the
    formal parameters you can reference the variable ARGC which will be
    set to the number of arguments passed into the function as well as
    ARGV0 ARGV1 ARGV2 ... which will have the actual values of the
    arguments passed in. This facilitates creating macros with optional
    arguments. Additionally ARGV holds the list of all arguments given
    to the macro and ARGN holds the list of argument pass the last
    expected argument.</p>
    </li>
    
    <li><b><code><a name="MAKE_DIRECTORY">MAKE_DIRECTORY</a></code></b>: Old directory creation
    command. Use the FILE command.<br>
    <p>This command has been superceded by the FILE(MAKE_DIRECTORY
    ...) command. It is provided for compatibility with older CMake
    code.<br>
    </p>
    <pre>  MAKE_DIRECTORY(directory)<br></pre>
    <p>Creates the specified directory. Full paths should be given.
    Any parent directories that do not exist will also be created. Use
    with care.</p>
    </li>
    
    <li><b><code><a name="MARK_AS_ADVANCED">MARK_AS_ADVANCED</a></code></b>: Mark cmake cached
    variables as advanced.<br>
    <pre>  MARK_AS_ADVANCED([CLEAR|FORCE] VAR VAR2 VAR...)<br></pre>
    <p>Mark the named cached variables as advanced. An advanced
    variable will not be displayed in any of the cmake GUIs unless the
    show advanced option is on. If CLEAR is the first argument advanced
    variables are changed back to unadvanced. If FORCE is the first
    argument, then the variable is made advanced. If neither FORCE nor
    CLEAR is specified, new values will be marked as advanced, but if
    the variable already has an advanced/non-advanced state, it will not
    be changed.</p>
    </li>
    
    <li><b><code><a name="MATH">MATH</a></code></b>: Mathematical expressions.<br>
    <pre>  MATH(EXPR &lt;output variable&gt; &lt;math expression&gt;)<br></pre>
    <p>EXPR evaluates mathematical expression and return result in
    the output variable. Example mathematical expression is '5 * ( 10 +
    13 )'.</p>
    </li>
    
    <li><b><code><a name="MESSAGE">MESSAGE</a></code></b>: Display a message to the user.<br>
    <pre>  MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR]<br>          "message to display" ...)<br></pre>
    <p>By default the message is displayed in a pop up window
    (CMakeSetup), or in the stdout of cmake, or the error section of
    ccmake. If the first argument is SEND_ERROR then an error is raised,
    and the generate phase will be skipped. If the first argument is
    FATAL_ERROR, all processing is halted. If the first argument is
    STATUS then the message is displayed in the progress line for the
    GUI, or with a -- in the command line cmake.</p>
    </li>
    
    <li><b><code><a name="OPTION">OPTION</a></code></b>: Provides an option that the
    user can optionally select.<br>
    <pre>  OPTION(OPTION_VAR "help string describing option"<br>         [initial value])<br></pre>
    <p>Provide an option for the user to select as ON or OFF. If no
    initial value is provided, OFF is used.</p>
    </li>
    
    <li><b><code><a name="OUTPUT_REQUIRED_FILES">OUTPUT_REQUIRED_FILES</a></code></b>: Output a list of
    required source files for a specified source file.<br>
    <pre>  OUTPUT_REQUIRED_FILES(srcfile outputfile)<br></pre>
    <p>Outputs a list of all the source files that are required by
    the specified srcfile. This list is written into outputfile. This is
    similar to writing out the dependencies for srcfile except that it
    jumps from .h files into .cxx, .c and .cpp files if possible.</p>
    </li>
    
    <li><b><code><a name="PROJECT">PROJECT</a></code></b>: Set a name for the entire
    project.<br>
    <pre>  PROJECT(projectname [CXX] [C] [Java])<br></pre>
    <p>Sets the name of the project. This creates the variables
    projectname_BINARY_DIR and projectname_SOURCE_DIR. Optionally you
    can specify which languages your project supports. By default all
    languages are supported. If you do not have a C++ compiler, but want
    to build a c program with cmake, then use this option.</p>
    </li>
    
    <li><b><code><a name="QT_WRAP_CPP">QT_WRAP_CPP</a></code></b>: Create QT Wrappers.<br>
    <pre>  QT_WRAP_CPP(resultingLibraryName DestName<br>              SourceLists ...)<br></pre>
    <p>Produce moc files for all the .h files listed in the
    SourceLists. The moc files will be added to the library using the
    DestName source list.</p>
    </li>
    
    <li><b><code><a name="QT_WRAP_UI">QT_WRAP_UI</a></code></b>: Create QT user interfaces
    Wrappers.<br>
    <pre>  QT_WRAP_UI(resultingLibraryName HeadersDestName<br>             SourcesDestName SourceLists ...)<br></pre>
    <p>Produce .h and .cxx files for all the .ui files listed in the
    SourceLists. The .h files will be added to the library using the
    HeadersDestNamesource list. The .cxx files will be added to the
    library using the SourcesDestNamesource list.</p>
    </li>
    
    <li><b><code><a name="REMOVE">REMOVE</a></code></b>: Old list item removal command.
    Use the LIST command.<br>
    <p>This command has been superceded by the LIST(REMOVE ...)
    command. It is provided for compatibility with older CMake code.<br>
    </p>
    <pre>  REMOVE(VAR VALUE VALUE ...)<br></pre>
    <p>Removes VALUE from the variable VAR. This is typically used
    to remove entries from a vector (e.g. semicolon separated list).
    VALUE is expanded.</p>
    </li>
    
    <li><b><code><a name="REMOVE_DEFINITIONS">REMOVE_DEFINITIONS</a></code></b>: Removes -D define
    flags to the command line of C and C++ compilers.<br>
    <pre>  REMOVE_DEFINITIONS(-DFOO -DBAR ...)<br></pre>
    <p>Removes flags from command line of C and C++ compilers. This
    command can be used to remove any flag from a compile line, but the
    -D flag is accepted most C/C++ compilers. Other flags may not be as
    portable.</p>
    </li>
    
    <li><b><code><a name="SEPARATE_ARGUMENTS">SEPARATE_ARGUMENTS</a></code></b>: Split space
    separated arguments into a semi-colon separated list.<br>
    <pre>  SEPARATE_ARGUMENTS(VARIABLE)<br></pre>
    <p>Convert the value of VARIABLE to a semi-colon separated list.
    All spaces are replaced with ';'. This helps with generating command
    lines.</p>
    </li>
    
    <li><b><code><a name="SET">SET</a></code></b>: Set a CMAKE variable to a given
    value.<br>
    <pre>  SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])<br></pre>
    <p>Within CMake sets VAR to the value VALUE. VALUE is expanded
    before VAR is set to it. If CACHE is present, then the VAR is put in
    the cache. TYPE and DOCSTRING are required. TYPE is used by the
    CMake GUI to choose a widget with which the user sets a value. The
    value for TYPE may be one of<br>
    </p>
    <pre>  FILEPATH = File chooser dialog.<br>  PATH     = Directory chooser dialog.<br>  STRING   = Arbitrary string.<br>  BOOL     = Boolean ON/OFF checkbox.<br>  INTERNAL = No GUI entry (used for persistent variables).<br></pre>
    <p>If TYPE is INTERNAL, then the VALUE is always written into
    the cache, replacing any values existing in the cache. If it is not
    a cache variable, then this always writes into the current makefile.
    The FORCE option will overwrite the cache value removing any changes
    by the user.<br>
    </p>
    <pre>  SET(VAR VALUE1 ... VALUEN).<br></pre>
    <p>In this case VAR is set to a semicolon separated list of
    values.<br>
    </p>
    <p>VAR can be an environment variable such as:<br>
    </p>
    <pre>  SET( ENV{PATH} /home/martink )<br></pre>
    <p>in which case the environment variable will be set.</p>
    </li>
    
    <li><b><code><a name="SET_DIRECTORY_PROPERTIES">SET_DIRECTORY_PROPERTIES</a></code></b>: Set a
    property of the directory.<br>
    <pre>  SET_DIRECTORY_PROPERTIES(PROPERTIES prop1 value1 prop2 value2)<br></pre>
    <p>Set a property for the current directory and subdirectories.
    If the property is not found, CMake will report an error. The
    properties include: INCLUDE_DIRECTORIES, LINK_DIRECTORIES,
    INCLUDE_REGULAR_EXPRESSION, and ADDITIONAL_MAKE_CLEAN_FILES.<br>
    </p>
    <p>ADDITIONAL_MAKE_CLEAN_FILES is a list of files that will be
    cleaned as a part of "make clean" stage.</p>
    </li>
    
    <li><b><code><a name="SET_SOURCE_FILES_PROPERTIES">SET_SOURCE_FILES_PROPERTIES</a></code></b>: Source
    files can have properties that affect how they are built.<br>
    <pre>  SET_SOURCE_FILES_PROPERTIES(file1 file2 ...<br>                              PROPERTIES prop1 value1<br>                              prop2 value2 ...)<br></pre>
    <p>Set properties on a file. The syntax for the command is to
    list all the files you want to change, and then provide the values
    you want to set next. You can make up your own properties as well.
    The following are used by CMake. The ABSTRACT flag (boolean) is used
    by some class wrapping commands. If WRAP_EXCLUDE (boolean) is true
    then many wrapping commands will ignore this file. If GENERATED
    (boolean) is true then it is not an error if this source file does
    not exist when it is added to a target. Obviously, it must be
    created (presumably by a custom command) before the target is built.
    If the HEADER_FILE_ONLY (boolean) property is true then dependency
    information is not created for that file (this is set automatically,
    based on the file's name's extension and is probably only used by
    Makefiles). OBJECT_DEPENDS (string) adds dependencies to the object
    file. COMPILE_FLAGS (string) is passed to the compiler as additional
    command line arguments when the source file is compiled. If SYMBOLIC
    (boolean) is set to true the build system will be informed that the
    source file is not actually created on disk but instead used as a
    symbolic name for a build rule.</p>
    </li>
    
    <li><b><code><a name="SET_TARGET_PROPERTIES">SET_TARGET_PROPERTIES</a></code></b>: Targets can have
    properties that affect how they are built.<br>
    <pre>  SET_TARGET_PROPERTIES(target1 target2 ...<br>                        PROPERTIES prop1 value1<br>                        prop2 value2 ...)<br></pre>
    <p>Set properties on a target. The syntax for the command is to
    list all the files you want to change, and then provide the values
    you want to set next. You can use any prop value pair you want and
    extract it later with the GET_TARGET_PROPERTY command.<br>
    </p>
    <p>Properties that affect the name of a target's output file are
    as follows. The PREFIX and SUFFIX properties override the default
    target name prefix (such as "lib") and suffix (such as ".so").
    IMPORT_PREFIX and IMPORT_SUFFIX are the equivalent properties for
    the import library corresponding to a DLL (for SHARED library
    targets). OUTPUT_NAME sets the real name of a target when it is
    built and can be used to help create two targets of the same name
    even though CMake requires unique logical target names. There is
    also a &lt;CONFIG&gt;_OUTPUT_NAME that can set the output name on a
    per-configuration basis. &lt;CONFIG&gt;_POSTFIX sets a postfix for
    the real name of the target when it is built under the configuration
    named by &lt;CONFIG&gt; (in upper-case, such as "DEBUG_POSTFIX").
    The value of this property is initialized when the target is created
    to the value of the variable CMAKE_&lt;CONFIG&gt;_POSTFIX (except
    for executable targets because earlier CMake versions which did not
    use this variable for executables).<br>
    </p>
    <p>The LINK_FLAGS property can be used to add extra flags to the
    link step of a target. LINK_FLAGS_&lt;CONFIG&gt; will add to the
    configuration &lt;CONFIG&gt;, for example, DEBUG, RELEASE,
    MINSIZEREL, RELWITHDEBINFO. DEFINE_SYMBOL sets the name of the
    preprocessor symbol defined when compiling sources in a shared
    library. If not set here then it is set to target_EXPORTS by default
    (with some substitutions if the target is not a valid C identifier).
    This is useful for headers to know whether they are being included
    from inside their library our outside to properly setup
    dllexport/dllimport decorations. The COMPILE_FLAGS property sets
    additional compiler flags used to build sources within the target.
    It may also be used to pass additional preprocessor definitions.<br>
    </p>
    <p>The LINKER_LANGUAGE property is used to change the tool used
    to link an executable or shared library. The default is set the
    language to match the files in the library. CXX and C are common
    values for this property.<br>
    </p>
    <p>For shared libraries VERSION and SOVERSION can be used to
    specify the build version and api version respectively. When
    building or installing appropriate symlinks are created if the
    platform supports symlinks and the linker supports so-names. If only
    one of both is specified the missing is assumed to have the same
    version number. For executables VERSION can be used to specify the
    build version. When building or installing appropriate symlinks are
    created if the platform supports symlinks. For shared libraries and
    executables on Windows the VERSION attribute is parsed to extract a
    "major.minor" version number. These numbers are used as the image
    version of the binary. <br>
    </p>
    <p>There are a few properties used to specify RPATH rules.
    INSTALL_RPATH is a semicolon-separated list specifying the rpath to
    use in installed targets (for platforms that support it).
    INSTALL_RPATH_USE_LINK_PATH is a boolean that if set to true will
    append directories in the linker search path and outside the project
    to the INSTALL_RPATH. SKIP_BUILD_RPATH is a boolean specifying
    whether to skip automatic generation of an rpath allowing the target
    to run from the build tree. BUILD_WITH_INSTALL_RPATH is a boolean
    specifying whether to link the target in the build tree with the
    INSTALL_RPATH. This takes precedence over SKIP_BUILD_RPATH and
    avoids the need for relinking before installation. INSTALL_NAME_DIR
    is a string specifying the directory portion of the "install_name"
    field of shared libraries on Mac OSX to use in the installed
    targets. When the target is created the values of the variables
    CMAKE_INSTALL_RPATH, CMAKE_INSTALL_RPATH_USE_LINK_PATH,
    CMAKE_SKIP_BUILD_RPATH, CMAKE_BUILD_WITH_INSTALL_RPATH, and
    CMAKE_INSTALL_NAME_DIR are used to initialize these properties.<br>
    </p>
    <p>PROJECT_LABEL can be used to change the name of the target in
    an IDE like visual studio. VS_KEYWORD can be set to change the
    visual studio keyword, for example QT integration works better if
    this is set to Qt4VSv1.0.<br>
    </p>
    <p>When a library is built CMake by default generates code to
    remove any existing library using all possible names. This is needed
    to support libraries that switch between STATIC and SHARED by a user
    option. However when using OUTPUT_NAME to build a static and shared
    library of the same name using different logical target names the
    two targets will remove each other's files. This can be prevented by
    setting the CLEAN_DIRECT_OUTPUT property to 1.<br>
    </p>
    <p>The PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT properties are
    the old way to specify CMake scripts to run before and after
    installing a target. They are used only when the old INSTALL_TARGETS
    command is used to install the target. Use the INSTALL command
    instead.<br>
    </p>
    <p>The EXCLUDE_FROM_DEFAULT_BUILD property is used by the visual
    studio generators. If it is set to 1 the target will not be part of
    the default build when you select "Build Solution".</p>
    </li>
    
    <li><b><code><a name="SET_TESTS_PROPERTIES">SET_TESTS_PROPERTIES</a></code></b>: Set a property of
    the tests.<br>
    <pre>  SET_TESTS_PROPERTIES(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)<br></pre>
    <p>Set a property for the tests. If the property is not found,
    CMake will report an error. The properties include:<br>
    </p>
    <p>WILL_FAIL: If set to true, this will invert the pass/fail
    flag of the test.<br>
    </p>
    <p>PASS_REGULAR_EXPRESSION: If set, the test output will be
    checked against the specified regular expressions and at least one
    of the regular expressions has to match, otherwise the test will
    fail.<br>
    </p>
    <pre>  Example: PASS_REGULAR_EXPRESSION "TestPassed;All ok"<br></pre>
    <p>FAIL_REGULAR_EXPRESSION: If set, if the output will match to
    one of specified regular expressions, the test will fail.<br>
    </p>
    <pre>  Example: PASS_REGULAR_EXPRESSION "[^a-z]Error;ERROR;Failed"<br></pre>
    <p>Both PASS_REGULAR_EXPRESSION and FAIL_REGULAR_EXPRESSION
    expect a list of regular expressions.<br>
    </p>
    </li>
    
    <li><b><code><a name="SITE_NAME">SITE_NAME</a></code></b>: Set the given variable to
    the name of the computer.<br>
    <pre>  SITE_NAME(variable)<br></pre></li>
    
    <li><b><code><a name="SOURCE_GROUP">SOURCE_GROUP</a></code></b>: Define a grouping for
    sources in the makefile.<br>
    <pre>  SOURCE_GROUP(name [REGULAR_EXPRESSION regex] [FILES src1 src2 ...])<br></pre>
    <p>Defines a group into which sources will be placed in project
    files. This is mainly used to setup file tabs in Visual Studio. Any
    file whose name is listed or matches the regular expression will be
    placed in this group. If a file matches multiple groups, the LAST
    group that explicitly lists the file will be favored, if any. If no
    group explicitly lists the file, the LAST group whose regular
    expression matches the file will be favored.<br>
    </p>
    <p>The name of the group may contain backslashes to specify
    subgroups:<br>
    </p>
    <pre>  SOURCE_GROUP(outer\\inner ...)<br></pre>
    <p>For backwards compatibility, this command is also supports
    the format:<br>
    </p>
    <pre>  SOURCE_GROUP(name regex)</pre></li>
    
    <li><b><code><a name="STRING">STRING</a></code></b>: String operations.<br>
    <pre>  STRING(REGEX MATCH &lt;regular_expression&gt;<br>         &lt;output variable&gt; &lt;input&gt; [&lt;input&gt;...])<br>  STRING(REGEX MATCHALL &lt;regular_expression&gt;<br>         &lt;output variable&gt; &lt;input&gt; [&lt;input&gt;...])<br>  STRING(REGEX REPLACE &lt;regular_expression&gt;<br>         &lt;replace_expression&gt; &lt;output variable&gt;<br>         &lt;input&gt; [&lt;input&gt;...])<br>  STRING(REPLACE &lt;match_expression&gt;<br>         &lt;replace_expression&gt; &lt;output variable&gt;<br>         &lt;input&gt; [&lt;input&gt;...])<br>  STRING(COMPARE EQUAL &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)<br>  STRING(COMPARE NOTEQUAL &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)<br>  STRING(COMPARE LESS &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)<br>  STRING(COMPARE GREATER &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)<br>  STRING(ASCII &lt;number&gt; [&lt;number&gt; ...] &lt;output variable&gt;)<br>  STRING(CONFIGURE &lt;string1&gt; &lt;output variable&gt;<br>         [@ONLY] [ESCAPE_QUOTES])<br>  STRING(TOUPPER &lt;string1&gt; &lt;output variable&gt;)<br>  STRING(TOLOWER &lt;string1&gt; &lt;output variable&gt;)<br>  STRING(LENGTH &lt;string&gt; &lt;output variable&gt;)<br>  STRING(SUBSTRING &lt;string&gt; &lt;begin&gt; &lt;length&gt; &lt;output variable&gt;)<br></pre>
    <p>REGEX MATCH will match the regular expression once and store
    the match in the output variable.<br>
    </p>
    <p>REGEX MATCHALL will match the regular expression as many
    times as possible and store the matches in the output variable as a
    list.<br>
    </p>
    <p>REGEX REPLACE will match the regular expression as many times
    as possible and substitute the replacement expression for the match
    in the output. The replace expression may refer to paren-delimited
    subexpressions of the match using \1, \2, ..., \9. Note that two
    backslashes (\\1) are required in CMake code to get a backslash
    through argument parsing.<br>
    </p>
    <p>REPLACE will match the given expression and substitute the
    replacement expression for the match in the output. The replace
    expression may refer to paren-delimited subexpressions of the match
    using \1, \2, ..., \9. Note that two backslashes (\\1) are required
    in CMake code to get a backslash through argument parsing.<br>
    </p>
    <p>COMPARE EQUAL/NOTEQUAL/LESS/GREATER will compare the strings
    and store true or false in the output variable.<br>
    </p>
    <p>ASCII will convert all numbers into corresponding ASCII
    characters.<br>
    </p>
    <p>CONFIGURE will transform a string like CONFIGURE_FILE
    transforms a file.<br>
    </p>
    <p>TOUPPER/TOLOWER will convert string to upper/lower
    characters.<br>
    </p>
    <p>LENGTH will return a given string's length.<br>
    </p>
    <p>SUBSTRING will return a substring of a given string.</p>
    </li>
    
    <li><b><code><a name="SUBDIR_DEPENDS">SUBDIR_DEPENDS</a></code></b>: Legacy command. Does
    nothing.<br>
    <pre>  SUBDIR_DEPENDS(subdir dep1 dep2 ...)<br></pre>
    <p>Does not do anything. This command used to help projects
    order parallel builds correctly. This functionality is now
    automatic.</p>
    </li>
    
    <li><b><code><a name="SUBDIRS">SUBDIRS</a></code></b>: Add a list of subdirectories
    to the build.<br>
    <pre>  SUBDIRS(dir1 dir2 ...[EXCLUDE_FROM_ALL exclude_dir1 exclude_dir2 ...] [PREORDER] )<br></pre>
    <p>Add a list of subdirectories to the build. The
    ADD_SUBDIRECTORY command should be used instead of SUBDIRS although
    SUBDIRS will still work. This will cause any CMakeLists.txt files in
    the sub directories to be processed by CMake. Any directories after
    the PREORDER flag are traversed first by makefile builds, the
    PREORDER flag has no effect on IDE projects. Any directories after
    the EXCLUDE_FROM_ALL marker will not be included in the top level
    makefile or project file. This is useful for having CMake create
    makefiles or projects for a set of examples in a project. You would
    want CMake to generate makefiles or project files for all the
    examples at the same time, but you would not want them to show up in
    the top level project or be built each time make is run from the
    top.</p>
    </li>
    
    <li><b><code><a name="TARGET_LINK_LIBRARIES">TARGET_LINK_LIBRARIES</a></code></b>: Link a target to
    given libraries.<br>
    <pre>  TARGET_LINK_LIBRARIES(target library1<br>                        &lt;debug | optimized&gt; library2<br>                        ...)<br></pre>
    <p>Specify a list of libraries to be linked into the specified
    target. The debug and optimized strings may be used to indicate that
    the next library listed is to be used only for that specific type of
    build</p>
    </li>
    
    <li><b><code><a name="TRY_COMPILE">TRY_COMPILE</a></code></b>: Try compiling some code.<br>
    <pre>  TRY_COMPILE(RESULT_VAR bindir srcdir<br>              projectName &lt;targetname&gt; &lt;CMAKE_FLAGS &lt;Flags&gt;&gt;<br>              &lt;OUTPUT_VARIABLE var&gt;)<br></pre>
    <p>Try compiling a program. Return the success or failure in
    RESULT_VAR. If &lt;target name&gt; is specified then build just that
    target otherwise the all or ALL_BUILD target is built.<br>
    </p>
    <pre>  TRY_COMPILE(RESULT_VAR bindir srcfile<br>              &lt;CMAKE_FLAGS &lt;Flags&gt;&gt;<br>              &lt;COMPILE_DEFINITIONS &lt;flags&gt; ...&gt;<br>              &lt;OUTPUT_VARIABLE var&gt;)<br></pre>
    <p>Try compiling a srcfile. Return the success or failure in
    RESULT_VAR. CMAKE_FLAGS can be used to pass -DVAR:TYPE=VALUE flags
    to cmake. Some extra flags that can be included are,
    INCLUDE_DIRECTORIES, LINK_DIRECTORIES, and LINK_LIBRARIES.
    COMPILE_DEFINITIONS are -Ddefinition that will be passed to the
    compile line. If srcfile is specified the files in
    bindir/CMakeFiles/CMakeTmp are cleaned automatically. If
    OUTPUT_VARIABLE is specified, then the output from the build process
    is stored in the given variable. TRY_COMPILE creates a CMakeList.txt
    file on the fly, and in that file it looks like this:<br>
    </p>
    <pre>  ADD_DEFINITIONS( &lt;expanded COMPILE_DEFINITIONS from calling cmake&gt;)<br>  INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})<br>  LINK_DIRECTORIES(${LINK_DIRECTORIES})<br>  ADD_EXECUTABLE(cmTryCompileExec sources)<br>  TARGET_LINK_LIBRARIES(cmTryCompileExec ${LINK_LIBRARIES})<br></pre>

    </li>
    
    <li><b><code><a name="TRY_RUN">TRY_RUN</a></code></b>: Try compiling and then running
    some code.<br>
    <pre>  TRY_RUN(RUN_RESULT_VAR COMPILE_RESULT_VAR<br>          bindir srcfile &lt;CMAKE_FLAGS &lt;Flags&gt;&gt;<br>          &lt;COMPILE_DEFINITIONS &lt;flags&gt;&gt;<br>          &lt;OUTPUT_VARIABLE var&gt;<br>          &lt;ARGS &lt;arg1&gt; &lt;arg2&gt;...&gt;)<br></pre>
    <p>Try compiling a srcfile. Return the success or failure in
    COMPILE_RESULT_VAR. Then if the compile succeeded, run the
    executable and return the result in RUN_RESULT_VAR. If the
    executable was built, but failed for to run for some reason, then
    RUN_RESULT_VAR will be set to FAILED_TO_RUN, and the output will be
    in the COMPILE_RESULT_VAR. OUTPUT_VARIABLE specifies the name of the
    variable to put all of the standard output and standard error into.
    </p>
    </li>
    
    <li><b><code><a name="USE_MANGLED_MESA">USE_MANGLED_MESA</a></code></b>: Copy mesa headers for
    use in combination with system GL.<br>
    <pre>  USE_MANGLED_MESA(PATH_TO_MESA OUTPUT_DIRECTORY)<br></pre>
    <p>The path to mesa includes, should contain gl_mangle.h. The
    mesa headers are copied to the specified output directory. This
    allows mangled mesa headers to override other GL headers by being
    added to the include directory path earlier.</p>
    </li>
    
    <li><b><code><a name="UTILITY_SOURCE">UTILITY_SOURCE</a></code></b>: Specify the source tree
    of a third-party utility.<br>
    <pre>  UTILITY_SOURCE(cache_entry executable_name<br>                 path_to_source [file1 file2 ...])<br></pre>
    <p>When a third-party utility's source is included in the
    distribution, this command specifies its location and name. The
    cache entry will not be set unless the path_to_source and all listed
    files exist. It is assumed that the source tree of the utility will
    have been built before it is needed.</p>
    </li>
    
    <li><b><code><a name="VARIABLE_REQUIRES">VARIABLE_REQUIRES</a></code></b>: Assert satisfaction
    of an option's required variables.<br>
    <pre>  VARIABLE_REQUIRES(TEST_VARIABLE RESULT_VARIABLE<br>                    REQUIRED_VARIABLE1<br>                    REQUIRED_VARIABLE2 ...)<br></pre>
    <p>The first argument (TEST_VARIABLE) is the name of the
    variable to be tested, if that variable is false nothing else is
    done. If TEST_VARIABLE is true, then the next argument
    (RESULT_VARIABLE) is a variable that is set to true if all the
    required variables are set. The rest of the arguments are variables
    that must be true or not set to NOTFOUND to avoid an error. If any
    are not true, an error is reported.</p>
    </li>
    
    <li><b><code><a name="VTK_MAKE_INSTANTIATOR">VTK_MAKE_INSTANTIATOR</a></code></b>: Deprecated. For
    use only in VTK 4.0.<br>
    <pre>  VTK_MAKE_INSTANTIATOR(className outSourceList<br>                        src-list1 [src-list2 ..]<br>                        EXPORT_MACRO exportMacro<br>                        [HEADER_LOCATION dir]<br>                        [GROUP_SIZE groupSize]<br>                        [INCLUDES [file1 file2 ..]])<br></pre>
    <p>Generates a new class with the given name and adds its files
    to the given outSourceList. It registers the classes from the other
    given source lists with vtkInstantiator when it is loaded. The
    output source list should be added to the library with the classes
    it registers. The EXPORT_MACRO argument must be given and followed
    by the export macro to use when generating the class (ex.
    VTK_COMMON_EXPORT). The HEADER_LOCATION option must be followed by a
    path. It specifies the directory in which to place the generated
    class's header file. The generated class implementation files always
    go in the build directory corresponding to the CMakeLists.txt file
    containing the command. This is the default location for the header.
    The INCLUDES option can be followed by a list of zero or more files.
    These files will be #included by the generated instantiator header,
    and can be used to gain access to the specified exportMacro in the
    C++ code.</p>
    </li>
    
    <li><b><code><a name="VTK_WRAP_JAVA">VTK_WRAP_JAVA</a></code></b>: Deprecated. For use only
    in VTK 4.0.<br>
    <pre>  VTK_WRAP_JAVA(resultingLibraryName SourceListName<br>                class1 class2 ...)<br></pre>
    <p>Create Java wrappers for VTK classes.</p>
    </li>
    
    <li><b><code><a name="VTK_WRAP_PYTHON">VTK_WRAP_PYTHON</a></code></b>: Deprecated. For use
    only in VTK 4.0.<br>
    <pre>  VTK_WRAP_PYTHON(resultingLibraryName SourceListName<br>                  class1 class2 ...)<br></pre>
    <p>Create Python wrappers for VTK classes.</p>
    </li>
    
    <li><b><code><a name="VTK_WRAP_TCL">VTK_WRAP_TCL</a></code></b>: Deprecated. For use only
    in VTK 4.0.<br>
    <pre>  VTK_WRAP_TCL(resultingLibraryName [SOURCES]<br>               SourceListName class1 class2 ...<br>               [COMMANDS CommandName1 CommandName2 ...])<br></pre>
    <p>Create Tcl wrappers for VTK classes.</p>
    </li>
    
    <li><b><code><a name="WHILE">WHILE</a></code></b>: Evaluate a group of commands
    while a condition is true<br>
    <pre>  WHILE(condition)<br>    COMMAND1(ARGS ...)<br>    COMMAND2(ARGS ...)<br>    ...<br>  ENDWHILE(condition)<br></pre>
    <p>All commands between WHILE and the matching ENDWHILE are
    recorded without being invoked. Once the ENDWHILE is evaluated, the
    recorded list of commands is invoked as long as the condition is
    true. The condition is evaulated using the same logic as the IF
    command.</p>
    </li>
    
    <li><b><code><a name="WRITE_FILE">WRITE_FILE</a></code></b>: Write a message to a file.<br>
    <pre>  WRITE_FILE(filename "message to write"... [APPEND])<br></pre>
    <p>The first argument is the file name, the rest of the
    arguments are messages to write. If the argument APPEND is
    specified, then the message will be appended.<br>
    </p>
    <p>NOTE 1: FILE WRITE and FILE APPEND do exactly the same as
    this one but add some more functionality.<br>
    </p>
    <p>NOTE 2: When using WRITE_FILE the produced file cannot be
    used as an input to CMake (CONFIGURE_FILE, source file ...) because
    it will lead to an infinite loop. Use CONFIGURE_FILE if you want to
    generate input files to CMake.</p>
    </li>
</ul>
</body>
</html>
